# 羊咩快报 - 后端设计文档

## 后端架构概述

羊咩快报后端采用Django + Django REST Framework构建，基于微服务思想设计，支持AI内容生成、多模态内容管理、实时同步阅读等核心功能。

### 技术栈

- **核心框架**: Django 4.2 + Django REST Framework 3.14
- **数据库**: MySQL 8.0 (主库) + Redis 7.0 (缓存)
- **任务队列**: Celery + Redis
- **Web服务器**: Nginx + Gunicorn
- **容器化**: Docker + Docker Compose
- **消息队列**: Redis Pub/Sub + WebSocket
- **文件存储**: 阿里云OSS / AWS S3
- **监控**: Prometheus + Grafana
- **日志**: ELK Stack (Elasticsearch + Logstash + Kibana)

### 系统架构图

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Web Client    │    │  Mobile Client  │    │  Admin Panel    │
└─────────┬───────┘    └─────────┬───────┘    └─────────┬───────┘
          │                      │                      │
          └──────────────────────┼──────────────────────┘
                                 │
              ┌─────────────────────────────────┐
              │         Nginx (Load Balancer)   │
              └─────────────────┬───────────────┘
                                │
              ┌─────────────────────────────────┐
              │        Django Application       │
              │  ┌─────────────────────────────┐ │
              │  │      REST API Layer         │ │
              │  ├─────────────────────────────┤ │
              │  │     Business Logic Layer    │ │
              │  ├─────────────────────────────┤ │
              │  │       Data Access Layer     │ │
              │  └─────────────────────────────┘ │
              └─────────────────┬───────────────┘
                                │
        ┌───────────────────────┼───────────────────────┐
        │                       │                       │
┌───────▼──────┐    ┌──────────▼───────┐    ┌─────────▼────────┐
│    MySQL     │    │      Redis       │    │   File Storage   │
│   (Primary)  │    │    (Cache)       │    │   (OSS/S3)       │
└──────────────┘    └──────────────────┘    └──────────────────┘
        │                       │                       │
┌───────▼──────┐    ┌──────────▼───────┐    ┌─────────▼────────┐
│    MySQL     │    │     Celery       │    │   AI Services    │
│  (Read Only) │    │  (Task Queue)    │    │  (TTS/Content)   │
└──────────────┘    └──────────────────┘    └──────────────────┘
```

## 项目结构

```
yangmie_backend/
├── manage.py                      # Django管理脚本
├── requirements.txt               # Python依赖
├── docker-compose.yml             # Docker编排
├── Dockerfile                     # Docker镜像
├── nginx.conf                     # Nginx配置
├── gunicorn.conf.py              # Gunicorn配置
├── celery_worker.py              # Celery工作进程
├── yangmie_backend/              # 项目主目录
│   ├── __init__.py
│   ├── settings/                 # 设置模块
│   │   ├── __init__.py
│   │   ├── base.py              # 基础设置
│   │   ├── development.py       # 开发环境设置
│   │   ├── production.py        # 生产环境设置
│   │   └── testing.py           # 测试环境设置
│   ├── urls.py                  # 主路由配置
│   ├── wsgi.py                  # WSGI应用
│   ├── asgi.py                  # ASGI应用(WebSocket支持)
│   └── celery.py                # Celery配置
├── apps/                        # 应用模块
│   ├── __init__.py
│   ├── users/                   # 用户管理
│   │   ├── __init__.py
│   │   ├── models.py            # 用户模型
│   │   ├── serializers.py       # 序列化器
│   │   ├── views.py             # 视图
│   │   ├── urls.py              # 路由
│   │   ├── admin.py             # 后台管理
│   │   ├── permissions.py       # 权限管理
│   │   ├── signals.py           # 信号处理
│   │   └── tests.py             # 测试
│   ├── content/                 # 内容管理
│   │   ├── __init__.py
│   │   ├── models/              # 分层模型
│   │   │   ├── __init__.py
│   │   │   ├── news.py          # 资讯模型
│   │   │   ├── article.py       # 文章模型
│   │   │   ├── audio.py         # 音频模型
│   │   │   ├── video.py         # 视频模型
│   │   │   └── sync.py          # 同步模型
│   │   ├── serializers/         # 序列化器
│   │   ├── views/               # 视图
│   │   ├── urls.py
│   │   ├── admin.py
│   │   ├── tasks.py             # 异步任务
│   │   ├── utils.py             # 工具函数
│   │   └── tests/
│   ├── analytics/               # 数据分析
│   ├── notifications/           # 通知系统
│   ├── recommendations/         # 推荐系统
│   ├── ai_services/            # AI服务
│   └── common/                  # 公共模块
│       ├── __init__.py
│       ├── mixins.py            # 混入类
│       ├── pagination.py        # 分页器
│       ├── permissions.py       # 权限基类
│       ├── renderers.py         # 响应渲染器
│       ├── exceptions.py        # 异常处理
│       ├── validators.py        # 验证器
│       └── utils.py             # 公共工具
├── utils/                       # 工具模块
│   ├── __init__.py
│   ├── cache.py                 # 缓存工具
│   ├── storage.py               # 文件存储
│   ├── ai_client.py             # AI客户端
│   ├── websocket.py             # WebSocket处理
│   └── decorators.py            # 装饰器
├── configs/                     # 配置文件
│   ├── __init__.py
│   ├── redis.py                 # Redis配置
│   ├── database.py              # 数据库配置
│   ├── storage.py               # 存储配置
│   └── logging.py               # 日志配置
├── scripts/                     # 脚本文件
│   ├── init_data.py             # 初始化数据
│   ├── migrate.py               # 数据迁移
│   └── deploy.py                # 部署脚本
├── static/                      # 静态文件
├── media/                       # 媒体文件
├── logs/                        # 日志文件
└── tests/                       # 测试文件
    ├── __init__.py
    ├── test_models.py
    ├── test_views.py
    ├── test_tasks.py
    └── fixtures/                # 测试数据
```

## 核心应用设计

### 1. 用户管理应用 (users)

#### 1.1 用户模型

```python
# apps/users/models.py
from django.contrib.auth.models import AbstractUser
from django.db import models
import uuid

class User(AbstractUser):
    """扩展用户模型"""
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    nickname = models.CharField(max_length=50, blank=True)
    avatar = models.ImageField(upload_to='avatars/', null=True, blank=True)
    phone = models.CharField(max_length=20, blank=True)
    birth_date = models.DateField(null=True, blank=True)
    gender = models.CharField(
        max_length=10,
        choices=[('male', '男'), ('female', '女'), ('other', '其他')],
        blank=True
    )
    bio = models.TextField(blank=True)
    is_verified = models.BooleanField(default=False)
    premium_until = models.DateTimeField(null=True, blank=True)
    interest_tags = models.JSONField(default=list)
    listening_preferences = models.JSONField(default=dict)
    location = models.CharField(max_length=100, blank=True)
    last_login_ip = models.GenericIPAddressField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nickname or self.username

    @property
    def is_premium(self):
        if not self.premium_until:
            return False
        return timezone.now() < self.premium_until

class UserPreference(models.Model):
    """用户偏好设置"""
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='preferences')
    language = models.CharField(max_length=10, default='zh-CN')
    theme = models.CharField(
        max_length=10,
        choices=[('light', '浅色'), ('dark', '深色'), ('auto', '自动')],
        default='auto'
    )
    audio_quality = models.CharField(
        max_length=10,
        choices=[('low', '低'), ('medium', '中'), ('high', '高')],
        default='medium'
    )
    auto_play = models.BooleanField(default=True)
    notification_enabled = models.BooleanField(default=True)
    push_news = models.BooleanField(default=True)
    push_comments = models.BooleanField(default=True)
    preferred_voice = models.CharField(max_length=50, default='standard_female')
    playback_speed = models.DecimalField(max_digits=3, decimal_places=1, default=1.0)
    scene_preferences = models.JSONField(default=list)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

class UserProfile(models.Model):
    """用户画像"""
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='profile')
    age_group = models.CharField(
        max_length=10,
        choices=[
            ('18-24', '18-24岁'),
            ('25-34', '25-34岁'),
            ('35-44', '35-44岁'),
            ('45-54', '45-54岁'),
            ('55+', '55岁以上'),
            ('unknown', '未知')
        ],
        default='unknown'
    )
    interest_categories = models.JSONField(default=dict)  # 兴趣分类权重
    preferred_content_length = models.CharField(
        max_length=10,
        choices=[('short', '短'), ('medium', '中'), ('long', '长'), ('mixed', '混合')],
        default='mixed'
    )
    preferred_time_slots = models.JSONField(default=list)
    active_days = models.JSONField(default=list)
    device_preference = models.CharField(
        max_length=10,
        choices=[('mobile', '手机'), ('tablet', '平板'), ('desktop', '桌面'), ('mixed', '混合')],
        default='mobile'
    )
    content_freshness_preference = models.DecimalField(max_digits=3, decimal_places=2, default=0.7)
    diversity_preference = models.DecimalField(max_digits=3, decimal_places=2, default=0.5)
    interaction_frequency = models.CharField(
        max_length=10,
        choices=[('low', '低'), ('medium', '中'), ('high', '高')],
        default='medium'
    )
    social_activity_level = models.CharField(
        max_length=10,
        choices=[('lurker', '潜水'), ('commenter', '评论'), ('sharer', '分享'), ('creator', '创作')],
        default='lurker'
    )
    last_updated_at = models.DateTimeField(auto_now=True)
    created_at = models.DateTimeField(auto_now_add=True)
```

#### 1.2 用户认证视图

```python
# apps/users/views.py
from rest_framework import status, viewsets
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated, AllowAny
from rest_framework_simplejwt.views import TokenObtainPairView
from django.contrib.auth import authenticate
from .models import User, UserPreference
from .serializers import UserSerializer, UserPreferenceSerializer, LoginSerializer

class AuthViewSet(viewsets.GenericViewSet):
    """认证相关视图集"""
    permission_classes = [AllowAny]

    @action(detail=False, methods=['post'])
    def register(self, request):
        """用户注册"""
        serializer = UserSerializer(data=request.data)
        if serializer.is_valid():
            user = serializer.save()
            # 创建用户偏好设置
            UserPreference.objects.create(user=user)
            
            # 生成JWT Token
            from rest_framework_simplejwt.tokens import RefreshToken
            refresh = RefreshToken.for_user(user)
            
            return Response({
                'code': 200,
                'message': '注册成功',
                'data': {
                    'user': UserSerializer(user).data,
                    'tokens': {
                        'access': str(refresh.access_token),
                        'refresh': str(refresh)
                    }
                }
            }, status=status.HTTP_201_CREATED)
        
        return Response({
            'code': 400,
            'message': '注册失败',
            'errors': serializer.errors
        }, status=status.HTTP_400_BAD_REQUEST)

    @action(detail=False, methods=['post'])
    def login(self, request):
        """用户登录"""
        serializer = LoginSerializer(data=request.data)
        if serializer.is_valid():
            username = serializer.validated_data['username']
            password = serializer.validated_data['password']
            
            user = authenticate(username=username, password=password)
            if user:
                # 更新登录信息
                user.last_login_ip = self.get_client_ip(request)
                user.save()
                
                # 生成Token
                from rest_framework_simplejwt.tokens import RefreshToken
                refresh = RefreshToken.for_user(user)
                
                return Response({
                    'code': 200,
                    'message': '登录成功',
                    'data': {
                        'user': UserSerializer(user).data,
                        'tokens': {
                            'access': str(refresh.access_token),
                            'refresh': str(refresh)
                        }
                    }
                })
            
            return Response({
                'code': 401,
                'message': '用户名或密码错误'
            }, status=status.HTTP_401_UNAUTHORIZED)
        
        return Response({
            'code': 400,
            'message': '请求参数错误',
            'errors': serializer.errors
        }, status=status.HTTP_400_BAD_REQUEST)

    def get_client_ip(self, request):
        """获取客户端IP"""
        x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
        if x_forwarded_for:
            ip = x_forwarded_for.split(',')[0]
        else:
            ip = request.META.get('REMOTE_ADDR')
        return ip

class UserViewSet(viewsets.ModelViewSet):
    """用户管理视图集"""
    queryset = User.objects.all()
    serializer_class = UserSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        return User.objects.filter(id=self.request.user.id)

    @action(detail=False, methods=['get', 'put'])
    def preferences(self, request):
        """用户偏好设置"""
        try:
            preference = request.user.preferences
        except UserPreference.DoesNotExist:
            preference = UserPreference.objects.create(user=request.user)

        if request.method == 'GET':
            serializer = UserPreferenceSerializer(preference)
            return Response({
                'code': 200,
                'data': serializer.data
            })
        
        elif request.method == 'PUT':
            serializer = UserPreferenceSerializer(preference, data=request.data, partial=True)
            if serializer.is_valid():
                serializer.save()
                return Response({
                    'code': 200,
                    'message': '偏好设置更新成功',
                    'data': serializer.data
                })
            
            return Response({
                'code': 400,
                'message': '参数错误',
                'errors': serializer.errors
            }, status=status.HTTP_400_BAD_REQUEST)
```

### 2. 内容管理应用 (content)

#### 2.1 内容模型

```python
# apps/content/models/news.py
from django.db import models
from django.contrib.auth import get_user_model
import uuid

User = get_user_model()

class NewsCategory(models.Model):
    """资讯分类"""
    name = models.CharField(max_length=50)
    name_en = models.CharField(max_length=50, blank=True)
    description = models.TextField(blank=True)
    icon_url = models.URLField(blank=True)
    color_code = models.CharField(max_length=7, default='#4CD964')
    parent = models.ForeignKey('self', on_delete=models.SET_NULL, null=True, blank=True)
    sort_order = models.IntegerField(default=0)
    is_active = models.BooleanField(default=True)
    keywords = models.JSONField(default=list)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'news_categories'
        ordering = ['sort_order', 'name']

class NewsSource(models.Model):
    """资讯来源"""
    SOURCE_TYPES = [
        ('rss', 'RSS'),
        ('api', 'API'),
        ('crawler', '爬虫')
    ]
    
    name = models.CharField(max_length=100)
    website_url = models.URLField(blank=True)
    rss_url = models.URLField(blank=True)
    api_endpoint = models.URLField(blank=True)
    source_type = models.CharField(max_length=10, choices=SOURCE_TYPES)
    credibility_score = models.DecimalField(max_digits=3, decimal_places=2, default=0.80)
    is_active = models.BooleanField(default=True)
    crawl_interval = models.IntegerField(default=3600)  # 秒
    last_crawled_at = models.DateTimeField(null=True, blank=True)
    config = models.JSONField(default=dict)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'news_sources'

class NewsMetadata(models.Model):
    """资讯元数据"""
    CONTENT_TYPES = [
        ('article', '文章'),
        ('video', '视频'),
        ('audio', '音频')
    ]
    
    id = models.BigAutoField(primary_key=True)
    source = models.ForeignKey(NewsSource, on_delete=models.CASCADE)
    title = models.CharField(max_length=500)
    summary = models.TextField(blank=True)
    author = models.CharField(max_length=100, blank=True)
    source_url = models.URLField(unique=True)
    cover_image_url = models.URLField(blank=True)
    published_at = models.DateTimeField()
    crawled_at = models.DateTimeField(auto_now_add=True)
    language = models.CharField(max_length=10, default='zh-CN')
    category = models.ForeignKey(NewsCategory, on_delete=models.SET_NULL, null=True)
    content_type = models.CharField(max_length=10, choices=CONTENT_TYPES)
    tags = models.JSONField(default=list)
    keywords = models.JSONField(default=list)
    sentiment_score = models.DecimalField(max_digits=3, decimal_places=2, null=True)
    importance_score = models.DecimalField(max_digits=3, decimal_places=2, null=True)
    
    # 统计字段
    view_count = models.BigIntegerField(default=0)
    like_count = models.IntegerField(default=0)
    share_count = models.IntegerField(default=0)
    comment_count = models.IntegerField(default=0)
    
    duration = models.IntegerField(null=True, blank=True)  # 音视频时长
    is_processed = models.BooleanField(default=False)
    is_duplicate = models.BooleanField(default=False)
    duplicate_of = models.ForeignKey('self', on_delete=models.SET_NULL, null=True, blank=True)
    is_active = models.BooleanField(default=True)
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'news_metadata'
        indexes = [
            models.Index(fields=['published_at']),
            models.Index(fields=['content_type']),
            models.Index(fields=['is_active']),
            models.Index(fields=['importance_score']),
        ]

    @property
    def has_audio(self):
        return hasattr(self, 'audio_content')
    
    @property
    def has_article(self):
        return hasattr(self, 'article_content')
    
    @property
    def has_video(self):
        return hasattr(self, 'video_content')
    
    @property
    def sync_reading_available(self):
        return self.has_audio and self.has_article and hasattr(self, 'sync_data')
```

#### 2.2 文章内容模型

```python
# apps/content/models/article.py
from django.db import models
from .news import NewsMetadata

class ArticleContent(models.Model):
    """文章内容"""
    id = models.BigAutoField(primary_key=True)
    news = models.OneToOneField(NewsMetadata, on_delete=models.CASCADE, related_name='article_content')
    content = models.TextField()  # 文章正文
    html_content = models.TextField(blank=True)  # HTML格式
    markdown_content = models.TextField(blank=True)  # Markdown格式
    content_structure = models.JSONField(default=dict)  # 结构化数据
    word_count = models.IntegerField(default=0)
    read_time_estimate = models.IntegerField(default=0)  # 预估阅读时间(分钟)
    
    # TTS相关
    tts_enabled = models.BooleanField(default=True)
    tts_script = models.TextField(blank=True)  # TTS专用脚本
    
    # 扩展内容
    related_images = models.JSONField(default=list)
    related_links = models.JSONField(default=list)
    
    # SEO
    seo_description = models.CharField(max_length=500, blank=True)
    seo_keywords = models.CharField(max_length=300, blank=True)
    
    # 质量评分
    content_quality_score = models.DecimalField(max_digits=3, decimal_places=2, null=True)
    readability_score = models.DecimalField(max_digits=3, decimal_places=2, null=True)
    
    # 原创性
    is_original = models.BooleanField(default=False)
    plagiarism_check_result = models.JSONField(default=dict)
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'article_content'
        indexes = [
            models.Index(fields=['word_count']),
            models.Index(fields=['content_quality_score']),
            models.Index(fields=['tts_enabled']),
        ]

    def save(self, *args, **kwargs):
        if self.content and not self.word_count:
            self.word_count = len(self.content)
            # 估算阅读时间：平均每分钟200-250字
            self.read_time_estimate = max(1, self.word_count // 225)
        super().save(*args, **kwargs)
```

#### 2.3 音频内容模型

```python
# apps/content/models/audio.py
from django.db import models
from .news import NewsMetadata
from .article import ArticleContent

class AudioContent(models.Model):
    """音频内容"""
    AUDIO_QUALITY_CHOICES = [
        ('low', '低质量'),
        ('medium', '中等质量'),
        ('high', '高质量')
    ]
    
    GENERATION_METHOD_CHOICES = [
        ('tts', 'TTS生成'),
        ('human', '人工录制'),
        ('ai_clone', 'AI克隆')
    ]
    
    id = models.BigAutoField(primary_key=True)
    news = models.OneToOneField(NewsMetadata, on_delete=models.CASCADE, related_name='audio_content')
    audio_url = models.URLField()  # 主音频URL
    backup_audio_urls = models.JSONField(default=list)  # 备用URL
    duration = models.IntegerField()  # 时长(秒)
    file_size = models.BigIntegerField(null=True)  # 文件大小(字节)
    bitrate = models.IntegerField(null=True)  # 比特率
    sample_rate = models.IntegerField(null=True)  # 采样率
    format = models.CharField(max_length=10, default='mp3')
    codec = models.CharField(max_length=50, blank=True)
    
    # 语音属性
    voice_type = models.CharField(max_length=50, blank=True)
    voice_gender = models.CharField(
        max_length=10,
        choices=[('male', '男性'), ('female', '女性'), ('mixed', '混合')],
        default='female'
    )
    speech_rate = models.DecimalField(max_digits=3, decimal_places=1, default=1.0)
    volume_level = models.DecimalField(max_digits=3, decimal_places=2, default=1.0)
    
    # 内容属性
    transcription = models.TextField(blank=True)  # 转录文字
    chapter_timestamps = models.JSONField(default=list)  # 章节时间戳
    
    # 关联文章(支持音频+文章联动)
    related_article = models.ForeignKey(
        ArticleContent, 
        on_delete=models.SET_NULL, 
        null=True, 
        blank=True,
        related_name='linked_audios'
    )
    
    # 同步阅读
    sync_reading_enabled = models.BooleanField(default=False)
    sync_reading_data = models.JSONField(default=dict)  # 同步数据
    
    # 音频质量和生成
    audio_quality = models.CharField(max_length=10, choices=AUDIO_QUALITY_CHOICES, default='medium')
    generation_method = models.CharField(max_length=10, choices=GENERATION_METHOD_CHOICES, default='tts')
    tts_config = models.JSONField(default=dict)  # TTS配置
    
    # 音效和背景
    background_music_url = models.URLField(blank=True)
    audio_effects = models.JSONField(default=dict)
    
    # 下载和离线
    download_enabled = models.BooleanField(default=True)
    offline_enabled = models.BooleanField(default=True)
    
    # 统计数据
    play_count = models.BigIntegerField(default=0)
    download_count = models.IntegerField(default=0)
    completion_rate = models.DecimalField(max_digits=5, decimal_places=2, default=0)  # 平均完成率
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'audio_content'
        indexes = [
            models.Index(fields=['duration']),
            models.Index(fields=['voice_type']),
            models.Index(fields=['sync_reading_enabled']),
            models.Index(fields=['play_count']),
        ]
```

#### 2.4 同步阅读模型

```python
# apps/content/models/sync.py
from django.db import models
from .audio import AudioContent
from .article import ArticleContent

class AudioArticleSync(models.Model):
    """音频文章同步阅读"""
    SYNC_TYPE_CHOICES = [
        ('full', '完整同步'),
        ('partial', '部分同步'),
        ('chapter_based', '基于章节')
    ]
    
    id = models.BigAutoField(primary_key=True)
    audio = models.ForeignKey(AudioContent, on_delete=models.CASCADE, related_name='sync_mappings')
    article = models.ForeignKey(ArticleContent, on_delete=models.CASCADE, related_name='sync_mappings')
    sync_type = models.CharField(max_length=15, choices=SYNC_TYPE_CHOICES, default='full')
    
    # 同步数据 - JSON结构存储段落和时间映射
    sync_data = models.JSONField()
    # 数据结构示例:
    # {
    #   "sync_mapping": {
    #     "paragraphs": [
    #       {
    #         "paragraph_id": "p1",
    #         "start_time": 15,
    #         "end_time": 45,
    #         "text": "段落内容...",
    #         "confidence": 0.92
    #       }
    #     ],
    #     "chapters": [
    #       {
    #         "title": "第一章",
    #         "start_time": 0,
    #         "end_time": 120,
    #         "paragraph_ids": ["p1", "p2"]
    #       }
    #     ],
    #     "highlights": [
    #       {
    #         "start_time": 30,
    #         "end_time": 35,
    #         "text": "重点内容",
    #         "type": "important"
    #       }
    #     ]
    #   }
    # }
    
    # 同步配置
    auto_scroll_enabled = models.BooleanField(default=True)
    highlight_enabled = models.BooleanField(default=True)
    reading_speed_factor = models.DecimalField(max_digits=3, decimal_places=2, default=1.0)
    sync_accuracy = models.DecimalField(max_digits=3, decimal_places=2, default=0.95)
    last_sync_position = models.IntegerField(default=0)  # 上次同步位置(秒)
    
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'audio_article_sync'
        unique_together = ['audio', 'article']
        indexes = [
            models.Index(fields=['sync_type']),
            models.Index(fields=['is_active']),
        ]

class UserPlayProgress(models.Model):
    """用户播放进度"""
    CONTENT_TYPE_CHOICES = [
        ('article', '文章'),
        ('audio', '音频'),
        ('video', '视频')
    ]
    
    PLAY_MODE_CHOICES = [
        ('audio_only', '仅音频'),
        ('article_only', '仅文章'),
        ('sync_reading', '同步阅读'),
        ('video_only', '仅视频')
    ]
    
    id = models.BigAutoField(primary_key=True)
    user = models.ForeignKey('users.User', on_delete=models.CASCADE)
    news = models.ForeignKey('content.NewsMetadata', on_delete=models.CASCADE)
    content_type = models.CharField(max_length=10, choices=CONTENT_TYPE_CHOICES)
    content_id = models.BigIntegerField()  # 对应具体内容ID
    
    # 进度信息
    current_position = models.IntegerField(default=0)  # 当前位置
    total_duration = models.IntegerField(default=0)  # 总时长/长度
    progress_percentage = models.DecimalField(max_digits=5, decimal_places=2, default=0)
    sync_reading_position = models.CharField(max_length=50, blank=True)  # 同步阅读位置
    
    # 用户交互
    play_count = models.IntegerField(default=1)
    bookmark_positions = models.JSONField(default=list)  # 书签位置
    notes = models.JSONField(default=list)  # 用户笔记
    last_play_mode = models.CharField(max_length=15, choices=PLAY_MODE_CHOICES, default='audio_only')
    
    # 设备信息
    device_type = models.CharField(max_length=20, blank=True)
    app_version = models.CharField(max_length=20, blank=True)
    
    last_updated_at = models.DateTimeField(auto_now=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = 'user_play_progress'
        unique_together = ['user', 'news', 'content_type']
        indexes = [
            models.Index(fields=['user', 'last_updated_at']),
            models.Index(fields=['content_type', 'content_id']),
            models.Index(fields=['progress_percentage']),
        ]
```

#### 2.5 内容视图

```python
# apps/content/views/content_views.py
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated, AllowAny
from django.db.models import Q, F, Count, Avg
from django.utils import timezone
from ..models import NewsMetadata, ArticleContent, AudioContent, UserPlayProgress
from ..serializers import NewsMetadataSerializer, ContentDetailSerializer
from ..tasks import update_play_statistics
from utils.cache import cache_manager
from utils.pagination import CustomPagination

class ContentViewSet(viewsets.ReadOnlyModelViewSet):
    """内容管理视图集"""
    queryset = NewsMetadata.objects.filter(is_active=True)
    serializer_class = NewsMetadataSerializer
    permission_classes = [AllowAny]
    pagination_class = CustomPagination

    def get_queryset(self):
        queryset = super().get_queryset()
        
        # 内容类型过滤
        content_type = self.request.query_params.get('content_type')
        if content_type:
            queryset = queryset.filter(content_type=content_type)
        
        # 分类过滤
        category_id = self.request.query_params.get('category_id')
        if category_id:
            queryset = queryset.filter(category_id=category_id)
        
        # 搜索
        search = self.request.query_params.get('search')
        if search:
            queryset = queryset.filter(
                Q(title__icontains=search) |
                Q(summary__icontains=search) |
                Q(tags__icontains=search)
            )
        
        # 标签过滤
        tags = self.request.query_params.get('tags')
        if tags:
            tag_list = tags.split(',')
            for tag in tag_list:
                queryset = queryset.filter(tags__icontains=tag.strip())
        
        # 排序
        sort = self.request.query_params.get('sort', 'latest')
        if sort == 'latest':
            queryset = queryset.order_by('-published_at')
        elif sort == 'popular':
            queryset = queryset.order_by('-view_count', '-like_count')
        elif sort == 'recommended':
            # 这里可以接入推荐算法
            queryset = queryset.order_by('-importance_score', '-published_at')
        
        return queryset

    def retrieve(self, request, *args, **kwargs):
        """获取内容详情"""
        instance = self.get_object()
        
        # 增加浏览量
        NewsMetadata.objects.filter(id=instance.id).update(
            view_count=F('view_count') + 1
        )
        
        # 获取详细内容数据
        content_data = self._get_content_detail(instance, request.user)
        
        return Response({
            'code': 200,
            'message': 'success',
            'data': content_data
        })

    def _get_content_detail(self, news, user):
        """获取内容详情数据"""
        data = {
            'news': NewsMetadataSerializer(news).data,
            'contents': {},
            'user_progress': None,
            'related_content': []
        }
        
        # 获取具体内容
        if news.content_type == 'article' and hasattr(news, 'article_content'):
            from ..serializers import ArticleContentSerializer
            data['contents']['article'] = ArticleContentSerializer(news.article_content).data
        
        if news.content_type == 'audio' and hasattr(news, 'audio_content'):
            from ..serializers import AudioContentSerializer
            data['contents']['audio'] = AudioContentSerializer(news.audio_content).data
            
            # 检查是否有关联文章
            if news.audio_content.related_article:
                from ..serializers import ArticleContentSerializer
                data['contents']['article'] = ArticleContentSerializer(
                    news.audio_content.related_article
                ).data
        
        if news.content_type == 'video' and hasattr(news, 'video_content'):
            from ..serializers import VideoContentSerializer
            data['contents']['video'] = VideoContentSerializer(news.video_content).data
        
        # 获取同步数据
        if (news.content_type == 'audio' and 
            hasattr(news, 'audio_content') and 
            news.audio_content.sync_reading_enabled):
            sync_mappings = news.audio_content.sync_mappings.filter(is_active=True).first()
            if sync_mappings:
                from ..serializers import AudioArticleSyncSerializer
                data['sync_data'] = AudioArticleSyncSerializer(sync_mappings).data
        
        # 获取用户进度
        if user.is_authenticated:
            try:
                progress = UserPlayProgress.objects.get(
                    user=user,
                    news=news,
                    content_type=news.content_type
                )
                from ..serializers import UserPlayProgressSerializer
                data['user_progress'] = UserPlayProgressSerializer(progress).data
            except UserPlayProgress.DoesNotExist:
                pass
        
        # 获取相关内容
        related = NewsMetadata.objects.filter(
            category=news.category,
            is_active=True
        ).exclude(id=news.id)[:5]
        data['related_content'] = NewsMetadataSerializer(related, many=True).data
        
        return data

    @action(detail=True, methods=['post'])
    def switch_mode(self, request, pk=None):
        """切换播放模式"""
        if not request.user.is_authenticated:
            return Response({
                'code': 401,
                'message': '请先登录'
            }, status=status.HTTP_401_UNAUTHORIZED)
        
        news = self.get_object()
        from_mode = request.data.get('from_mode')
        to_mode = request.data.get('to_mode')
        current_position = request.data.get('current_position', 0)
        
        # 更新用户进度
        progress, created = UserPlayProgress.objects.get_or_create(
            user=request.user,
            news=news,
            content_type=news.content_type,
            defaults={
                'total_duration': news.duration or 0,
                'content_id': self._get_content_id(news)
            }
        )
        
        progress.current_position = current_position
        progress.last_play_mode = to_mode
        progress.progress_percentage = (
            (current_position / progress.total_duration * 100) 
            if progress.total_duration > 0 else 0
        )
        
        # 同步阅读模式的特殊处理
        if to_mode == 'sync_reading':
            sync_data = self._calculate_sync_position(news, current_position)
            if sync_data:
                progress.sync_reading_position = sync_data.get('current_paragraph')
        
        progress.save()
        
        # 异步更新统计数据
        update_play_statistics.delay(
            user_id=request.user.id,
            news_id=news.id,
            action='mode_switch',
            data={
                'from_mode': from_mode,
                'to_mode': to_mode,
                'position': current_position
            }
        )
        
        return Response({
            'code': 200,
            'message': '模式切换成功',
            'data': {
                'current_mode': to_mode,
                'position': current_position,
                'sync_data': sync_data if to_mode == 'sync_reading' else None
            }
        })

    def _get_content_id(self, news):
        """获取具体内容ID"""
        if news.content_type == 'article' and hasattr(news, 'article_content'):
            return news.article_content.id
        elif news.content_type == 'audio' and hasattr(news, 'audio_content'):
            return news.audio_content.id
        elif news.content_type == 'video' and hasattr(news, 'video_content'):
            return news.video_content.id
        return 0

    def _calculate_sync_position(self, news, audio_position):
        """计算同步阅读位置"""
        if (news.content_type != 'audio' or 
            not hasattr(news, 'audio_content') or
            not news.audio_content.sync_reading_enabled):
            return None
        
        sync_mapping = news.audio_content.sync_mappings.filter(is_active=True).first()
        if not sync_mapping:
            return None
        
        paragraphs = sync_mapping.sync_data.get('sync_mapping', {}).get('paragraphs', [])
        current_paragraph = None
        
        for paragraph in paragraphs:
            if paragraph['start_time'] <= audio_position <= paragraph['end_time']:
                current_paragraph = paragraph['paragraph_id']
                break
        
        return {
            'current_paragraph': current_paragraph,
            'scroll_position': self._calculate_scroll_position(current_paragraph),
            'highlight_words': self._get_highlight_words(paragraphs, audio_position)
        }

    @action(detail=False, methods=['get'])
    def search(self, request):
        """搜索内容"""
        query = request.query_params.get('q', '').strip()
        if not query:
            return Response({
                'code': 400,
                'message': '搜索关键词不能为空'
            }, status=status.HTTP_400_BAD_REQUEST)
        
        # 使用缓存
        cache_key = f"search:{hash(query)}:{request.query_params.urlencode()}"
        cached_result = cache_manager.get(cache_key)
        if cached_result:
            return Response(cached_result)
        
        # 执行搜索
        queryset = self.get_queryset()
        queryset = queryset.filter(
            Q(title__icontains=query) |
            Q(summary__icontains=query) |
            Q(tags__icontains=query) |
            Q(keywords__icontains=query)
        )
        
        # 应用其他过滤条件
        content_type = request.query_params.get('content_type')
        if content_type:
            queryset = queryset.filter(content_type=content_type)
        
        # 时长过滤
        duration_min = request.query_params.get('duration_min')
        duration_max = request.query_params.get('duration_max')
        if duration_min:
            queryset = queryset.filter(duration__gte=int(duration_min))
        if duration_max:
            queryset = queryset.filter(duration__lte=int(duration_max))
        
        # 日期过滤
        date_from = request.query_params.get('date_from')
        date_to = request.query_params.get('date_to')
        if date_from:
            queryset = queryset.filter(published_at__gte=date_from)
        if date_to:
            queryset = queryset.filter(published_at__lte=date_to)
        
        # 排序
        sort = request.query_params.get('sort', 'relevance')
        if sort == 'relevance':
            # 这里可以实现更复杂的相关性排序
            queryset = queryset.order_by('-importance_score', '-published_at')
        elif sort == 'date':
            queryset = queryset.order_by('-published_at')
        elif sort == 'popularity':
            queryset = queryset.order_by('-view_count', '-like_count')
        
        # 分页
        page = self.paginate_queryset(queryset)
        serializer = self.get_serializer(page, many=True)
        
        result = self.get_paginated_response(serializer.data)
        
        # 缓存结果
        cache_manager.set(cache_key, result.data, timeout=300)  # 5分钟缓存
        
        return result
```

### 3. AI服务应用 (ai_services)

#### 3.1 AI服务模型

```python
# apps/ai_services/models.py
from django.db import models

class AIModelConfig(models.Model):
    """AI模型配置"""
    MODEL_TYPES = [
        ('text_generation', '文本生成'),
        ('text_to_speech', '文本转语音'),
        ('video_generation', '视频生成'),
        ('image_generation', '图像生成'),
        ('translation', '翻译')
    ]
    
    model_name = models.CharField(max_length=100)
    model_type = models.CharField(max_length=20, choices=MODEL_TYPES)
    provider = models.CharField(max_length=50)  # openai, azure, anthropic等
    api_endpoint = models.URLField(blank=True)
    model_version = models.CharField(max_length=50, blank=True)
    max_tokens = models.IntegerField(null=True)
    temperature = models.DecimalField(max_digits=3, decimal_places=2, null=True)
    top_p = models.DecimalField(max_digits=3, decimal_places=2, null=True)
    frequency_penalty = models.DecimalField(max_digits=3, decimal_places=2, null=True)
    presence_penalty = models.DecimalField(max_digits=3, decimal_places=2, null=True)
    cost_per_token = models.DecimalField(max_digits=8, decimal_places=6, null=True)
    rate_limit_rpm = models.IntegerField(null=True)  # 每分钟请求限制
    rate_limit_tpm = models.IntegerField(null=True)  # 每分钟token限制
    is_active = models.BooleanField(default=True)
    priority = models.IntegerField(default=1)  # 优先级
    config_json = models.JSONField(default=dict)  # 其他配置
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'ai_model_configs'
        ordering = ['priority', 'model_name']

class ContentGenerationTask(models.Model):
    """内容生成任务"""
    TASK_TYPES = [
        ('text_generation', '文本生成'),
        ('audio_generation', '音频生成'),
        ('video_generation', '视频生成'),
        ('translation', '翻译')
    ]
    
    STATUS_CHOICES = [
        ('pending', '等待中'),
        ('processing', '处理中'),
        ('completed', '已完成'),
        ('failed', '失败'),
        ('cancelled', '已取消')
    ]
    
    PRIORITY_CHOICES = [
        ('low', '低'),
        ('normal', '普通'),
        ('high', '高'),
        ('urgent', '紧急')
    ]
    
    id = models.BigAutoField(primary_key=True)
    task_type = models.CharField(max_length=20, choices=TASK_TYPES)
    news = models.ForeignKey('content.NewsMetadata', on_delete=models.CASCADE)
    model_config = models.ForeignKey(AIModelConfig, on_delete=models.PROTECT)
    input_data = models.JSONField()  # 输入数据
    output_data = models.JSONField(null=True)  # 输出数据
    status = models.CharField(max_length=15, choices=STATUS_CHOICES, default='pending')
    priority = models.CharField(max_length=10, choices=PRIORITY_CHOICES, default='normal')
    progress_percentage = models.IntegerField(default=0)
    estimated_duration = models.IntegerField(null=True)  # 预估耗时(秒)
    actual_duration = models.IntegerField(null=True)  # 实际耗时(秒)
    error_message = models.TextField(blank=True)
    retry_count = models.IntegerField(default=0)
    max_retries = models.IntegerField(default=3)
    scheduled_at = models.DateTimeField(null=True)  # 计划执行时间
    started_at = models.DateTimeField(null=True)
    completed_at = models.DateTimeField(null=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'content_generation_tasks'
        indexes = [
            models.Index(fields=['status', 'priority']),
            models.Index(fields=['scheduled_at']),
            models.Index(fields=['task_type']),
        ]

class APIUsageStats(models.Model):
    """API使用统计"""
    model_config = models.ForeignKey(AIModelConfig, on_delete=models.CASCADE)
    date = models.DateField()
    request_count = models.IntegerField(default=0)
    token_count = models.BigIntegerField(default=0)
    success_count = models.IntegerField(default=0)
    error_count = models.IntegerField(default=0)
    total_cost = models.DecimalField(max_digits=10, decimal_places=4, default=0)
    avg_response_time = models.IntegerField(default=0)  # 平均响应时间(ms)
    peak_hour = models.IntegerField(null=True)  # 峰值小时
    error_types = models.JSONField(default=dict)  # 错误类型统计
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'api_usage_stats'
        unique_together = ['model_config', 'date']
```

#### 3.2 AI服务客户端

```python
# utils/ai_client.py
import openai
import aiohttp
import asyncio
from typing import Dict, Any, Optional
from django.conf import settings
from apps.ai_services.models import AIModelConfig, APIUsageStats
import time
import logging

logger = logging.getLogger(__name__)

class AIServiceClient:
    """AI服务客户端"""
    
    def __init__(self):
        self.openai_client = openai.AsyncOpenAI(api_key=settings.OPENAI_API_KEY)
        self.session = None
    
    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()

    async def generate_text(self, prompt: str, model_config: AIModelConfig) -> Dict[str, Any]:
        """文本生成"""
        start_time = time.time()
        
        try:
            if model_config.provider == 'openai':
                response = await self._openai_text_generation(prompt, model_config)
            elif model_config.provider == 'anthropic':
                response = await self._anthropic_text_generation(prompt, model_config)
            else:
                raise ValueError(f"不支持的提供商: {model_config.provider}")
            
            # 记录统计
            duration = int((time.time() - start_time) * 1000)
            await self._record_usage(model_config, 'success', duration, response.get('usage', {}))
            
            return {
                'success': True,
                'content': response['content'],
                'usage': response.get('usage', {}),
                'model': response.get('model'),
                'duration': duration
            }
            
        except Exception as e:
            duration = int((time.time() - start_time) * 1000)
            await self._record_usage(model_config, 'error', duration, {}, str(e))
            logger.error(f"文本生成失败: {e}")
            
            return {
                'success': False,
                'error': str(e),
                'duration': duration
            }

    async def _openai_text_generation(self, prompt: str, model_config: AIModelConfig) -> Dict[str, Any]:
        """OpenAI文本生成"""
        response = await self.openai_client.chat.completions.create(
            model=model_config.model_name,
            messages=[{"role": "user", "content": prompt}],
            temperature=float(model_config.temperature or 0.7),
            max_tokens=model_config.max_tokens or 4000,
            top_p=float(model_config.top_p or 1.0),
            frequency_penalty=float(model_config.frequency_penalty or 0),
            presence_penalty=float(model_config.presence_penalty or 0)
        )
        
        return {
            'content': response.choices[0].message.content,
            'usage': {
                'prompt_tokens': response.usage.prompt_tokens,
                'completion_tokens': response.usage.completion_tokens,
                'total_tokens': response.usage.total_tokens
            },
            'model': response.model
        }

    async def _anthropic_text_generation(self, prompt: str, model_config: AIModelConfig) -> Dict[str, Any]:
        """Anthropic文本生成"""
        import anthropic
        
        client = anthropic.AsyncAnthropic(api_key=settings.ANTHROPIC_API_KEY)
        
        response = await client.messages.create(
            model=model_config.model_name,
            max_tokens=model_config.max_tokens or 4000,
            temperature=float(model_config.temperature or 0.7),
            messages=[{"role": "user", "content": prompt}]
        )
        
        return {
            'content': response.content[0].text,
            'usage': {
                'input_tokens': response.usage.input_tokens,
                'output_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens
            },
            'model': response.model
        }

    async def generate_tts(self, text: str, model_config: AIModelConfig, voice: str = 'alloy') -> Dict[str, Any]:
        """文本转语音"""
        start_time = time.time()
        
        try:
            if model_config.provider == 'openai':
                response = await self._openai_tts(text, model_config, voice)
            elif model_config.provider == 'azure':
                response = await self._azure_tts(text, model_config, voice)
            else:
                raise ValueError(f"不支持的TTS提供商: {model_config.provider}")
            
            duration = int((time.time() - start_time) * 1000)
            await self._record_usage(model_config, 'success', duration, {'text_length': len(text)})
            
            return {
                'success': True,
                'audio_url': response['audio_url'],
                'duration': response.get('duration'),
                'file_size': response.get('file_size'),
                'generation_time': duration
            }
            
        except Exception as e:
            duration = int((time.time() - start_time) * 1000)
            await self._record_usage(model_config, 'error', duration, {}, str(e))
            logger.error(f"TTS生成失败: {e}")
            
            return {
                'success': False,
                'error': str(e),
                'duration': duration
            }

    async def _openai_tts(self, text: str, model_config: AIModelConfig, voice: str) -> Dict[str, Any]:
        """OpenAI TTS"""
        response = await self.openai_client.audio.speech.create(
            model="tts-1-hd",
            voice=voice,
            input=text,
            response_format="mp3"
        )
        
        # 保存音频文件到存储服务
        from utils.storage import upload_audio_file
        audio_url = await upload_audio_file(response.content, f"tts_{int(time.time())}.mp3")
        
        return {
            'audio_url': audio_url,
            'file_size': len(response.content)
        }

    async def _record_usage(self, model_config: AIModelConfig, status: str, duration: int, 
                          usage: Dict = None, error: str = None):
        """记录API使用统计"""
        from django.utils import timezone
        from django.db import transaction
        
        today = timezone.now().date()
        usage = usage or {}
        
        try:
            with transaction.atomic():
                stats, created = await APIUsageStats.objects.aget_or_create(
                    model_config=model_config,
                    date=today,
                    defaults={
                        'request_count': 0,
                        'token_count': 0,
                        'success_count': 0,
                        'error_count': 0,
                        'total_cost': 0,
                        'avg_response_time': 0,
                        'error_types': {}
                    }
                )
                
                # 更新统计数据
                stats.request_count += 1
                
                if status == 'success':
                    stats.success_count += 1
                    token_count = usage.get('total_tokens', 0)
                    stats.token_count += token_count
                    
                    # 计算成本
                    if model_config.cost_per_token and token_count:
                        cost = float(model_config.cost_per_token) * token_count
                        stats.total_cost += cost
                else:
                    stats.error_count += 1
                    
                    # 记录错误类型
                    if error:
                        error_type = type(error).__name__
                        error_types = stats.error_types
                        error_types[error_type] = error_types.get(error_type, 0) + 1
                        stats.error_types = error_types
                
                # 更新平均响应时间
                total_requests = stats.success_count + stats.error_count
                stats.avg_response_time = (
                    (stats.avg_response_time * (total_requests - 1) + duration) // total_requests
                )
                
                await stats.asave()
                
        except Exception as e:
            logger.error(f"记录API使用统计失败: {e}")

# 全局AI客户端实例
ai_client = AIServiceClient()
```

#### 3.3 内容生成任务

```python
# apps/ai_services/tasks.py
from celery import shared_task
from django.utils import timezone
from .models import ContentGenerationTask, AIModelConfig
from apps.content.models import NewsMetadata, ArticleContent, AudioContent
from utils.ai_client import ai_client
import logging

logger = logging.getLogger(__name__)

@shared_task(bind=True, max_retries=3)
def generate_audio_content(self, task_id: int):
    """生成音频内容任务"""
    try:
        task = ContentGenerationTask.objects.get(id=task_id)
        task.status = 'processing'
        task.started_at = timezone.now()
        task.save()
        
        # 获取输入数据
        news = task.news
        input_data = task.input_data
        text_content = input_data.get('text', '')
        voice_config = input_data.get('voice_config', {})
        
        if not text_content:
            # 如果没有直接文本，从文章内容获取
            if hasattr(news, 'article_content'):
                text_content = news.article_content.tts_script or news.article_content.content
            else:
                raise ValueError("没有找到可用的文本内容")
        
        # 处理文本长度，分块生成
        text_chunks = _split_text_for_tts(text_content)
        audio_segments = []
        
        total_chunks = len(text_chunks)
        
        for i, chunk in enumerate(text_chunks):
            # 更新进度
            progress = int((i / total_chunks) * 90)  # 留10%给后处理
            task.progress_percentage = progress
            task.save()
            
            # 生成音频
            async def generate_chunk():
                return await ai_client.generate_tts(
                    text=chunk,
                    model_config=task.model_config,
                    voice=voice_config.get('voice', 'alloy')
                )
            
            import asyncio
            result = asyncio.run(generate_chunk())
            
            if not result['success']:
                raise Exception(f"音频生成失败: {result['error']}")
            
            audio_segments.append({
                'chunk_index': i,
                'audio_url': result['audio_url'],
                'text': chunk,
                'duration': result.get('duration', 0)
            })
        
        # 合并音频片段（这里可以调用音频处理服务）
        final_audio_url = _merge_audio_segments(audio_segments)
        total_duration = sum(segment.get('duration', 0) for segment in audio_segments)
        
        # 创建音频内容记录
        audio_content = AudioContent.objects.create(
            news=news,
            audio_url=final_audio_url,
            duration=total_duration,
            voice_type=voice_config.get('voice', 'alloy'),
            voice_gender=voice_config.get('gender', 'female'),
            format='mp3',
            audio_quality='high',
            generation_method='tts',
            tts_config=voice_config,
            transcription=text_content
        )
        
        # 如果有对应的文章，建立关联
        if hasattr(news, 'article_content'):
            audio_content.related_article = news.article_content
            audio_content.save()
            
            # 生成同步阅读数据
            sync_data = _generate_sync_data(audio_content, news.article_content, audio_segments)
            if sync_data:
                from apps.content.models import AudioArticleSync
                AudioArticleSync.objects.create(
                    audio=audio_content,
                    article=news.article_content,
                    sync_data={'sync_mapping': sync_data},
                    auto_scroll_enabled=True,
                    highlight_enabled=True
                )
                audio_content.sync_reading_enabled = True
                audio_content.save()
        
        # 更新任务状态
        task.status = 'completed'
        task.progress_percentage = 100
        task.completed_at = timezone.now()
        task.actual_duration = int((timezone.now() - task.started_at).total_seconds())
        task.output_data = {
            'audio_content_id': audio_content.id,
            'audio_url': final_audio_url,
            'duration': total_duration,
            'chunks_count': len(audio_segments)
        }
        task.save()
        
        logger.info(f"音频内容生成完成: task_id={task_id}, audio_id={audio_content.id}")
        
    except Exception as e:
        logger.error(f"音频内容生成失败: task_id={task_id}, error={e}")
        
        task.status = 'failed'
        task.error_message = str(e)
        task.retry_count += 1
        task.save()
        
        # 重试逻辑
        if task.retry_count < task.max_retries:
            raise self.retry(countdown=60 * task.retry_count, exc=e)

def _split_text_for_tts(text: str, max_chunk_size: int = 4000) -> list:
    """将文本分割为适合TTS的块"""
    if len(text) <= max_chunk_size:
        return [text]
    
    chunks = []
    sentences = text.split('。')
    current_chunk = ''
    
    for sentence in sentences:
        if len(current_chunk) + len(sentence) + 1 <= max_chunk_size:
            current_chunk += sentence + '。'
        else:
            if current_chunk:
                chunks.append(current_chunk.strip())
            current_chunk = sentence + '。'
    
    if current_chunk:
        chunks.append(current_chunk.strip())
    
    return chunks

def _merge_audio_segments(segments: list) -> str:
    """合并音频片段"""
    # 这里应该调用音频处理服务来合并音频文件
    # 暂时返回第一个片段的URL作为示例
    if segments:
        # 实际实现中需要调用音频处理API
        return segments[0]['audio_url']
    return ''

def _generate_sync_data(audio_content, article_content, audio_segments):
    """生成同步阅读数据"""
    try:
        paragraphs = article_content.content_structure.get('paragraphs', [])
        if not paragraphs:
            return None
        
        sync_paragraphs = []
        current_time = 0
        
        # 简单的时间映射算法
        for i, paragraph in enumerate(paragraphs):
            # 估算该段落的时长
            para_text = paragraph.get('text', '')
            para_duration = len(para_text) * 0.1  # 简单估算：每字符0.1秒
            
            sync_paragraphs.append({
                'paragraph_id': paragraph.get('id', f'p{i+1}'),
                'start_time': current_time,
                'end_time': current_time + para_duration,
                'text': para_text,
                'confidence': 0.85  # 默认置信度
            })
            
            current_time += para_duration
        
        return {
            'paragraphs': sync_paragraphs,
            'chapters': article_content.content_structure.get('chapters', []),
            'highlights': []
        }
        
    except Exception as e:
        logger.error(f"生成同步数据失败: {e}")
        return None

@shared_task
def cleanup_failed_tasks():
    """清理失败的任务"""
    from datetime import timedelta
    
    cutoff_time = timezone.now() - timedelta(days=7)
    
    # 删除7天前的失败任务
    deleted_count = ContentGenerationTask.objects.filter(
        status='failed',
        created_at__lt=cutoff_time
    ).delete()
    
    logger.info(f"清理了 {deleted_count[0]} 个失败的生成任务")

@shared_task
def process_pending_tasks():
    """处理等待中的任务"""
    pending_tasks = ContentGenerationTask.objects.filter(
        status='pending',
        scheduled_at__lte=timezone.now()
    ).order_by('priority', 'created_at')[:10]  # 一次处理10个任务
    
    for task in pending_tasks:
        if task.task_type == 'audio_generation':
            generate_audio_content.delay(task.id)
        # 其他任务类型的处理逻辑
```

### 4. WebSocket实时同步

#### 4.1 WebSocket消费者

```python
# utils/websocket.py
import json
import asyncio
from channels.generic.websocket import AsyncWebsocketConsumer
from channels.db import database_sync_to_async
from django.contrib.auth.models import AnonymousUser
from apps.content.models import UserPlayProgress
import logging

logger = logging.getLogger(__name__)

class SyncConsumer(AsyncWebsocketConsumer):
    """同步阅读WebSocket消费者"""
    
    async def connect(self):
        self.news_id = self.scope['url_route']['kwargs']['news_id']
        self.room_group_name = f'sync_{self.news_id}'
        self.user = self.scope.get('user', AnonymousUser())
        
        # 加入房间组
        await self.channel_layer.group_add(
            self.room_group_name,
            self.channel_name
        )
        
        await self.accept()
        
        # 发送连接确认
        await self.send(text_data=json.dumps({
            'type': 'connection_established',
            'message': '连接已建立'
        }))

    async def disconnect(self, close_code):
        # 离开房间组
        await self.channel_layer.group_discard(
            self.room_group_name,
            self.channel_name
        )

    async def receive(self, text_data):
        try:
            data = json.loads(text_data)
            message_type = data.get('type')
            
            if message_type == 'auth':
                await self.handle_auth(data)
            elif message_type == 'position_update':
                await self.handle_position_update(data)
            elif message_type == 'sync_request':
                await self.handle_sync_request(data)
            else:
                await self.send_error('未知的消息类型')
                
        except json.JSONDecodeError:
            await self.send_error('无效的JSON格式')
        except Exception as e:
            logger.error(f"WebSocket消息处理错误: {e}")
            await self.send_error('服务器内部错误')

    async def handle_auth(self, data):
        """处理认证"""
        token = data.get('token')
        if not token:
            await self.send_error('缺少认证token')
            return
        
        # 验证JWT token
        user = await self.authenticate_token(token)
        if user:
            self.user = user
            await self.send(text_data=json.dumps({
                'type': 'auth_success',
                'message': '认证成功'
            }))
        else:
            await self.send_error('认证失败')

    async def handle_position_update(self, data):
        """处理位置更新"""
        if isinstance(self.user, AnonymousUser):
            await self.send_error('请先认证')
            return
        
        position = data.get('position')
        mode = data.get('mode', 'audio_only')
        paragraph_id = data.get('paragraph_id')
        
        # 更新用户进度
        await self.update_user_progress(position, mode, paragraph_id)
        
        # 广播给房间内其他用户（如果需要）
        # await self.channel_layer.group_send(
        #     self.room_group_name,
        #     {
        #         'type': 'sync_update',
        #         'data': {
        #             'user_id': self.user.id,
        #             'position': position,
        #             'mode': mode,
        #             'paragraph_id': paragraph_id
        #         }
        #     }
        # )

    async def handle_sync_request(self, data):
        """处理同步请求"""
        # 获取同步数据
        sync_data = await self.get_sync_data()
        
        await self.send(text_data=json.dumps({
            'type': 'sync_response',
            'data': sync_data
        }))

    async def sync_update(self, event):
        """发送同步更新到客户端"""
        await self.send(text_data=json.dumps({
            'type': 'sync_update',
            'data': event['data']
        }))

    async def send_error(self, message):
        """发送错误消息"""
        await self.send(text_data=json.dumps({
            'type': 'error',
            'message': message
        }))

    @database_sync_to_async
    def authenticate_token(self, token):
        """验证JWT token"""
        try:
            from rest_framework_simplejwt.tokens import UntypedToken
            from rest_framework_simplejwt.exceptions import InvalidToken, TokenError
            from django.contrib.auth import get_user_model
            
            User = get_user_model()
            
            # 验证token
            UntypedToken(token)
            
            # 解码token获取用户
            from rest_framework_simplejwt.authentication import JWTAuthentication
            jwt_auth = JWTAuthentication()
            validated_token = jwt_auth.get_validated_token(token)
            user = jwt_auth.get_user(validated_token)
            
            return user
            
        except (InvalidToken, TokenError, User.DoesNotExist):
            return None

    @database_sync_to_async
    def update_user_progress(self, position, mode, paragraph_id):
        """更新用户播放进度"""
        try:
            from apps.content.models import NewsMetadata
            
            news = NewsMetadata.objects.get(id=self.news_id)
            
            progress, created = UserPlayProgress.objects.get_or_create(
                user=self.user,
                news=news,
                content_type=news.content_type,
                defaults={
                    'total_duration': news.duration or 0,
                    'content_id': 0
                }
            )
            
            progress.current_position = position
            progress.last_play_mode = mode
            if paragraph_id:
                progress.sync_reading_position = paragraph_id
            
            if progress.total_duration > 0:
                progress.progress_percentage = (position / progress.total_duration) * 100
            
            progress.save()
            
        except Exception as e:
            logger.error(f"更新用户进度失败: {e}")

    @database_sync_to_async
    def get_sync_data(self):
        """获取同步数据"""
        try:
            from apps.content.models import NewsMetadata, AudioArticleSync
            
            news = NewsMetadata.objects.get(id=self.news_id)
            
            if hasattr(news, 'audio_content') and news.audio_content.sync_reading_enabled:
                sync_mapping = AudioArticleSync.objects.filter(
                    audio=news.audio_content,
                    is_active=True
                ).first()
                
                if sync_mapping:
                    return sync_mapping.sync_data
            
            return {}
            
        except Exception as e:
            logger.error(f"获取同步数据失败: {e}")
            return {}
```

### 5. 部署配置

#### 5.1 Docker配置

```dockerfile
# Dockerfile
FROM python:3.11-slim

WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    libffi-dev \
    libssl-dev \
    && rm -rf /var/lib/apt/lists/*

# 复制依赖文件
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY . .

# 创建非root用户
RUN useradd --create-home --shell /bin/bash app \
    && chown -R app:app /app
USER app

# 健康检查
HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \
    CMD python manage.py check --deploy || exit 1

EXPOSE 8000

CMD ["gunicorn", "--config", "gunicorn.conf.py", "yangmie_backend.wsgi:application"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  web:
    build: .
    ports:
      - "8000:8000"
    volumes:
      - ./logs:/app/logs
    environment:
      - DJANGO_SETTINGS_MODULE=yangmie_backend.settings.production
      - DATABASE_URL=mysql://user:password@db:3306/yangmie
      - REDIS_URL=redis://redis:6379/0
    depends_on:
      - db
      - redis
    restart: unless-stopped

  db:
    image: mysql:8.0
    environment:
      MYSQL_DATABASE: yangmie
      MYSQL_USER: user
      MYSQL_PASSWORD: password
      MYSQL_ROOT_PASSWORD: rootpassword
    volumes:
      - mysql_data:/var/lib/mysql
      - ./configs/mysql.cnf:/etc/mysql/conf.d/custom.cnf
    ports:
      - "3306:3306"
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    restart: unless-stopped

  celery:
    build: .
    command: celery -A yangmie_backend worker -l info
    volumes:
      - ./logs:/app/logs
    environment:
      - DJANGO_SETTINGS_MODULE=yangmie_backend.settings.production
      - DATABASE_URL=mysql://user:password@db:3306/yangmie
      - REDIS_URL=redis://redis:6379/0
    depends_on:
      - db
      - redis
    restart: unless-stopped

  celery-beat:
    build: .
    command: celery -A yangmie_backend beat -l info
    volumes:
      - ./logs:/app/logs
    environment:
      - DJANGO_SETTINGS_MODULE=yangmie_backend.settings.production
      - DATABASE_URL=mysql://user:password@db:3306/yangmie
      - REDIS_URL=redis://redis:6379/0
    depends_on:
      - db
      - redis
    restart: unless-stopped

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./static:/var/www/static
      - ./media:/var/www/media
    depends_on:
      - web
    restart: unless-stopped

volumes:
  mysql_data:
  redis_data:
```

#### 5.2 生产环境设置

```python
# yangmie_backend/settings/production.py
from .base import *
import os

# 安全设置
DEBUG = False
ALLOWED_HOSTS = ['api.yangmie.com', 'www.yangmie.com']

# 数据库
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': os.getenv('DB_NAME', 'yangmie'),
        'USER': os.getenv('DB_USER', 'root'),
        'PASSWORD': os.getenv('DB_PASSWORD'),
        'HOST': os.getenv('DB_HOST', 'localhost'),
        'PORT': os.getenv('DB_PORT', '3306'),
        'OPTIONS': {
            'charset': 'utf8mb4',
            'init_command': "SET sql_mode='STRICT_TRANS_TABLES'",
        },
    }
}

# Redis配置
REDIS_URL = os.getenv('REDIS_URL', 'redis://localhost:6379/0')

CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': REDIS_URL,
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
        }
    }
}

# Celery配置
CELERY_BROKER_URL = REDIS_URL
CELERY_RESULT_BACKEND = REDIS_URL
CELERY_ACCEPT_CONTENT = ['json']
CELERY_TASK_SERIALIZER = 'json'
CELERY_RESULT_SERIALIZER = 'json'
CELERY_TIMEZONE = TIME_ZONE

# 文件存储
DEFAULT_FILE_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage'
AWS_ACCESS_KEY_ID = os.getenv('AWS_ACCESS_KEY_ID')
AWS_SECRET_ACCESS_KEY = os.getenv('AWS_SECRET_ACCESS_KEY')
AWS_STORAGE_BUCKET_NAME = os.getenv('AWS_STORAGE_BUCKET_NAME')
AWS_S3_REGION_NAME = os.getenv('AWS_S3_REGION_NAME', 'us-east-1')

# 安全设置
SECURE_SSL_REDIRECT = True
SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')
SESSION_COOKIE_SECURE = True
CSRF_COOKIE_SECURE = True

# 日志配置
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
        'simple': {
            'format': '{levelname} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'file': {
            'level': 'INFO',
            'class': 'logging.FileHandler',
            'filename': '/app/logs/django.log',
            'formatter': 'verbose',
        },
        'console': {
            'level': 'INFO',
            'class': 'logging.StreamHandler',
            'formatter': 'simple',
        },
    },
    'root': {
        'handlers': ['console', 'file'],
        'level': 'INFO',
    },
    'loggers': {
        'django': {
            'handlers': ['console', 'file'],
            'level': 'INFO',
            'propagate': False,
        },
        'yangmie_backend': {
            'handlers': ['console', 'file'],
            'level': 'INFO',
            'propagate': False,
        },
    },
}

# API限流
REST_FRAMEWORK['DEFAULT_THROTTLE_RATES'] = {
    'anon': '100/hour',
    'user': '1000/hour',
    'auth': '10/min',
    'content': '100/min',
}
```

---

*此后端设计文档涵盖了羊咩快报项目的完整后端架构，包括Django应用设计、AI服务集成、WebSocket实时同步、部署配置等各个方面。可根据实际开发需求进行调整和扩展。*