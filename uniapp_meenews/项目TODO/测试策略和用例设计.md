# ç¾Šå’©å¿«æŠ¥ - æµ‹è¯•ç­–ç•¥å’Œç”¨ä¾‹è®¾è®¡

## æµ‹è¯•ç­–ç•¥æ¦‚è¿°

æœ¬æ–‡æ¡£åˆ¶å®šäº†ç¾Šå’©å¿«æŠ¥é¡¹ç›®çš„å…¨é¢æµ‹è¯•ç­–ç•¥ï¼ŒåŒ…æ‹¬å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•ã€ç”¨æˆ·ä½“éªŒæµ‹è¯•ã€æ€§èƒ½æµ‹è¯•å’Œå®‰å…¨æµ‹è¯•ã€‚ç¡®ä¿åº”ç”¨çš„é«˜è´¨é‡äº¤ä»˜ã€‚

---

## 1. æµ‹è¯•ç­–ç•¥æ¡†æ¶

### 1.1 æµ‹è¯•é‡‘å­—å¡”

```
    /\
   /UI\      <- 10% (E2Eæµ‹è¯•ã€UIæµ‹è¯•)
  /____\
 /      \
/Integration\ <- 20% (é›†æˆæµ‹è¯•ã€APIæµ‹è¯•)
/____________\
/            \
/   Unit Tests  \ <- 70% (å•å…ƒæµ‹è¯•)
/________________\
```

#### æµ‹è¯•åˆ†å±‚ç­–ç•¥
- **å•å…ƒæµ‹è¯• (70%)**: æµ‹è¯•ç‹¬ç«‹çš„å‡½æ•°ã€ç»„ä»¶å’Œç±»
- **é›†æˆæµ‹è¯• (20%)**: æµ‹è¯•æ¨¡å—é—´çš„äº¤äº’å’ŒAPI
- **UI/E2Eæµ‹è¯• (10%)**: æµ‹è¯•å®Œæ•´çš„ç”¨æˆ·æµç¨‹

### 1.2 æµ‹è¯•ç¯å¢ƒ

#### ç¯å¢ƒé…ç½®
1. **å¼€å‘ç¯å¢ƒ (Development)**
   - æœ¬åœ°å¼€å‘æµ‹è¯•
   - å¿«é€Ÿåé¦ˆå¾ªç¯
   - Mockæ•°æ®æ”¯æŒ

2. **æµ‹è¯•ç¯å¢ƒ (Testing)**
   - è‡ªåŠ¨åŒ–æµ‹è¯•æ‰§è¡Œ
   - çœŸå®æ•°æ®åº“
   - ç¬¬ä¸‰æ–¹æœåŠ¡Mock

3. **é¢„ç”Ÿäº§ç¯å¢ƒ (Staging)**
   - ç”Ÿäº§ç¯å¢ƒé•œåƒ
   - çœŸå®æ•°æ®
   - æ€§èƒ½æµ‹è¯•

4. **ç”Ÿäº§ç¯å¢ƒ (Production)**
   - ç›‘æ§å’ŒæŠ¥è­¦
   - é”™è¯¯è¿½è¸ª
   - ç”¨æˆ·è¡Œä¸ºåˆ†æ

---

## 2. åç«¯æµ‹è¯• (Django)

### 2.1 å•å…ƒæµ‹è¯•

#### æ¨¡å‹æµ‹è¯•
```python
# tests/test_models.py
import pytest
from django.test import TestCase
from django.core.exceptions import ValidationError
from apps.content.models import AudioContent, Artist, Album
from apps.users.models import User

class AudioContentModelTest(TestCase):
    def setUp(self):
        self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123'
        )
        
        self.artist = Artist.objects.create(
            name='Test Artist',
            bio='Test artist bio'
        )
        
        self.album = Album.objects.create(
            title='Test Album',
            artist=self.artist
        )

    def test_audio_content_creation(self):
        """æµ‹è¯•éŸ³é¢‘å†…å®¹åˆ›å»º"""
        audio = AudioContent.objects.create(
            title='Test Audio',
            description='Test description',
            audio_url='https://example.com/audio.mp3',
            artist=self.artist,
            album=self.album,
            duration=180,
            file_size=5242880,
            bitrate=320,
            format='mp3'
        )
        
        self.assertEqual(audio.title, 'Test Audio')
        self.assertEqual(audio.artist, self.artist)
        self.assertEqual(audio.duration, 180)
        self.assertTrue(audio.is_active)

    def test_audio_content_validation(self):
        """æµ‹è¯•éŸ³é¢‘å†…å®¹éªŒè¯"""
        with self.assertRaises(ValidationError):
            audio = AudioContent(
                title='',  # ç©ºæ ‡é¢˜åº”è¯¥å¤±è´¥
                audio_url='invalid-url',  # æ— æ•ˆURL
                duration=-10  # è´Ÿæ•°æ—¶é•¿
            )
            audio.full_clean()

    def test_audio_content_str_representation(self):
        """æµ‹è¯•å­—ç¬¦ä¸²è¡¨ç¤º"""
        audio = AudioContent.objects.create(
            title='Test Audio',
            artist=self.artist,
            audio_url='https://example.com/audio.mp3',
            duration=180
        )
        
        expected = f'Test Audio - {self.artist.name}'
        self.assertEqual(str(audio), expected)

    def test_play_count_increment(self):
        """æµ‹è¯•æ’­æ”¾æ¬¡æ•°å¢åŠ """
        audio = AudioContent.objects.create(
            title='Test Audio',
            artist=self.artist,
            audio_url='https://example.com/audio.mp3',
            duration=180
        )
        
        initial_count = audio.play_count
        audio.increment_play_count()
        
        self.assertEqual(audio.play_count, initial_count + 1)

    def test_user_favorites(self):
        """æµ‹è¯•ç”¨æˆ·æ”¶è—åŠŸèƒ½"""
        audio = AudioContent.objects.create(
            title='Test Audio',
            artist=self.artist,
            audio_url='https://example.com/audio.mp3',
            duration=180
        )
        
        # æ·»åŠ æ”¶è—
        audio.add_to_favorites(self.user)
        self.assertTrue(audio.is_favorited_by(self.user))
        
        # ç§»é™¤æ”¶è—
        audio.remove_from_favorites(self.user)
        self.assertFalse(audio.is_favorited_by(self.user))
```

#### APIè§†å›¾æµ‹è¯•
```python
# tests/test_views.py
import pytest
from django.test import TestCase
from django.urls import reverse
from rest_framework.test import APIClient
from rest_framework import status
from rest_framework_simplejwt.tokens import RefreshToken
from apps.users.models import User
from apps.content.models import AudioContent, Artist

class ContentAPITest(TestCase):
    def setUp(self):
        self.client = APIClient()
        self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123'
        )
        
        # ç”ŸæˆJWT token
        refresh = RefreshToken.for_user(self.user)
        self.access_token = refresh.access_token
        
        self.artist = Artist.objects.create(name='Test Artist')
        
        self.audio_content = AudioContent.objects.create(
            title='Test Audio',
            artist=self.artist,
            audio_url='https://example.com/audio.mp3',
            duration=180
        )

    def authenticate(self):
        """è®¤è¯ç”¨æˆ·"""
        self.client.credentials(HTTP_AUTHORIZATION=f'Bearer {self.access_token}')

    def test_get_content_list_unauthenticated(self):
        """æµ‹è¯•æœªè®¤è¯ç”¨æˆ·è·å–å†…å®¹åˆ—è¡¨"""
        url = reverse('content-list')
        response = self.client.get(url)
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertIn('results', response.data['data'])

    def test_get_content_detail_authenticated(self):
        """æµ‹è¯•è®¤è¯ç”¨æˆ·è·å–å†…å®¹è¯¦æƒ…"""
        self.authenticate()
        url = reverse('content-detail', kwargs={'pk': self.audio_content.id})
        response = self.client.get(url)
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['data']['id'], self.audio_content.id)
        self.assertEqual(response.data['data']['title'], 'Test Audio')

    def test_favorite_content(self):
        """æµ‹è¯•æ”¶è—å†…å®¹"""
        self.authenticate()
        url = reverse('user-favorites')
        data = {
            'content_id': self.audio_content.id,
            'content_type': 'audio'
        }
        
        response = self.client.post(url, data)
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        
        # éªŒè¯æ”¶è—æˆåŠŸ
        self.assertTrue(
            self.audio_content.is_favorited_by(self.user)
        )

    def test_search_content(self):
        """æµ‹è¯•å†…å®¹æœç´¢"""
        url = reverse('content-search')
        response = self.client.get(url, {'q': 'Test'})
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertGreaterEqual(len(response.data['data']['results']), 1)

    def test_play_history_recording(self):
        """æµ‹è¯•æ’­æ”¾å†å²è®°å½•"""
        self.authenticate()
        url = reverse('player-play')
        data = {
            'content_id': self.audio_content.id,
            'play_duration': 120,
            'completion_rate': 66.67,
            'device_type': 'mobile'
        }
        
        response = self.client.post(url, data)
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)

    def test_recommendation_api(self):
        """æµ‹è¯•æ¨èAPI"""
        self.authenticate()
        url = reverse('content-recommend')
        response = self.client.get(url)
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertIn('results', response.data['data'])

    def test_invalid_content_id(self):
        """æµ‹è¯•æ— æ•ˆå†…å®¹ID"""
        self.authenticate()
        url = reverse('content-detail', kwargs={'pk': 99999})
        response = self.client.get(url)
        
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)

    def test_rate_limiting(self):
        """æµ‹è¯•é¢‘ç‡é™åˆ¶"""
        url = reverse('content-search')
        
        # æ¨¡æ‹Ÿå¤§é‡è¯·æ±‚
        for i in range(101):  # å‡è®¾é™åˆ¶æ˜¯100æ¬¡/åˆ†é’Ÿ
            response = self.client.get(url, {'q': f'test{i}'})
            
        # æœ€åä¸€æ¬¡è¯·æ±‚åº”è¯¥è¢«é™åˆ¶
        self.assertEqual(response.status_code, status.HTTP_429_TOO_MANY_REQUESTS)
```

#### æœåŠ¡å±‚æµ‹è¯•
```python
# tests/test_services.py
import pytest
from unittest.mock import Mock, patch
from apps.ai.services import RecommendationEngine
from apps.content.services import AudioProcessingService
from apps.users.models import User

class RecommendationEngineTest(TestCase):
    def setUp(self):
        self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123'
        )
        self.engine = RecommendationEngine()

    @patch('apps.ai.services.RecommendationEngine.get_user_behavior')
    def test_generate_recommendations(self, mock_get_behavior):
        """æµ‹è¯•æ¨èç”Ÿæˆ"""
        # Mockç”¨æˆ·è¡Œä¸ºæ•°æ®
        mock_get_behavior.return_value = {
            'play_history': [],
            'favorites': [],
            'ratings': [],
            'search_history': []
        }
        
        recommendations = self.engine.generate_recommendations(self.user.id, limit=10)
        
        self.assertIsInstance(recommendations, list)
        self.assertLessEqual(len(recommendations), 10)

    def test_user_preference_analysis(self):
        """æµ‹è¯•ç”¨æˆ·åå¥½åˆ†æ"""
        behavior = {
            'play_history': [],
            'favorites': [],
            'ratings': []
        }
        
        preferences = self.engine.analyze_user_preferences(behavior)
        
        self.assertIn('favorite_categories', preferences)
        self.assertIn('favorite_artists', preferences)
        self.assertIn('listening_time_patterns', preferences)

    def test_content_similarity_calculation(self):
        """æµ‹è¯•å†…å®¹ç›¸ä¼¼åº¦è®¡ç®—"""
        content1_features = {
            'genre': 'pop',
            'tempo': 120,
            'energy': 0.8,
            'danceability': 0.7
        }
        
        content2_features = {
            'genre': 'pop',
            'tempo': 125,
            'energy': 0.85,
            'danceability': 0.75
        }
        
        similarity = self.engine.calculate_content_similarity(
            content1_features, 
            content2_features
        )
        
        self.assertGreaterEqual(similarity, 0.0)
        self.assertLessEqual(similarity, 1.0)
        self.assertGreater(similarity, 0.8)  # åº”è¯¥å¾ˆç›¸ä¼¼

class AudioProcessingServiceTest(TestCase):
    def setUp(self):
        self.service = AudioProcessingService()

    @patch('apps.content.services.AudioProcessingService.extract_audio_features')
    def test_audio_analysis(self, mock_extract):
        """æµ‹è¯•éŸ³é¢‘åˆ†æ"""
        mock_extract.return_value = {
            'duration': 180,
            'bitrate': 320,
            'sample_rate': 44100,
            'channels': 2,
            'tempo': 120,
            'key': 'C',
            'energy': 0.8
        }
        
        audio_url = 'https://example.com/test.mp3'
        features = self.service.analyze_audio(audio_url)
        
        self.assertEqual(features['duration'], 180)
        self.assertEqual(features['bitrate'], 320)
        mock_extract.assert_called_once_with(audio_url)

    def test_audio_format_validation(self):
        """æµ‹è¯•éŸ³é¢‘æ ¼å¼éªŒè¯"""
        valid_formats = ['mp3', 'm4a', 'wav', 'flac']
        invalid_formats = ['mp4', 'avi', 'txt', 'jpg']
        
        for format_type in valid_formats:
            self.assertTrue(self.service.is_valid_audio_format(format_type))
            
        for format_type in invalid_formats:
            self.assertFalse(self.service.is_valid_audio_format(format_type))

    def test_audio_quality_assessment(self):
        """æµ‹è¯•éŸ³é¢‘è´¨é‡è¯„ä¼°"""
        low_quality = {'bitrate': 128, 'sample_rate': 22050}
        medium_quality = {'bitrate': 192, 'sample_rate': 44100}
        high_quality = {'bitrate': 320, 'sample_rate': 44100}
        
        self.assertEqual(self.service.assess_audio_quality(low_quality), 'low')
        self.assertEqual(self.service.assess_audio_quality(medium_quality), 'medium')
        self.assertEqual(self.service.assess_audio_quality(high_quality), 'high')
```

### 2.2 é›†æˆæµ‹è¯•

#### æ•°æ®åº“é›†æˆæµ‹è¯•
```python
# tests/integration/test_database.py
import pytest
from django.test import TransactionTestCase
from django.db import transaction
from apps.users.models import User
from apps.content.models import AudioContent, Artist
from apps.player.models import PlayHistory

class DatabaseIntegrationTest(TransactionTestCase):
    def test_complex_query_performance(self):
        """æµ‹è¯•å¤æ‚æŸ¥è¯¢æ€§èƒ½"""
        # åˆ›å»ºæµ‹è¯•æ•°æ®
        users = []
        for i in range(100):
            user = User.objects.create_user(
                username=f'user{i}',
                email=f'user{i}@example.com',
                password='testpass123'
            )
            users.append(user)
        
        artist = Artist.objects.create(name='Test Artist')
        
        contents = []
        for i in range(1000):
            content = AudioContent.objects.create(
                title=f'Test Audio {i}',
                artist=artist,
                audio_url=f'https://example.com/audio{i}.mp3',
                duration=180 + i,
                play_count=i * 10
            )
            contents.append(content)
        
        # æµ‹è¯•å¤æ‚æŸ¥è¯¢
        import time
        start_time = time.time()
        
        # è·å–çƒ­é—¨å†…å®¹
        popular_contents = AudioContent.objects.filter(
            is_active=True,
            play_count__gte=100
        ).select_related('artist').order_by('-play_count')[:20]
        
        query_time = time.time() - start_time
        
        self.assertLess(query_time, 1.0)  # æŸ¥è¯¢åº”åœ¨1ç§’å†…å®Œæˆ
        self.assertGreater(len(popular_contents), 0)

    def test_transaction_integrity(self):
        """æµ‹è¯•äº‹åŠ¡å®Œæ•´æ€§"""
        user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123'
        )
        
        artist = Artist.objects.create(name='Test Artist')
        
        content = AudioContent.objects.create(
            title='Test Audio',
            artist=artist,
            audio_url='https://example.com/audio.mp3',
            duration=180
        )
        
        try:
            with transaction.atomic():
                # è®°å½•æ’­æ”¾å†å²
                PlayHistory.objects.create(
                    user=user,
                    content=content,
                    play_duration=120,
                    completion_rate=66.67
                )
                
                # å¢åŠ æ’­æ”¾æ¬¡æ•°
                content.play_count += 1
                content.save()
                
                # æ¨¡æ‹Ÿé”™è¯¯
                raise Exception("Simulated error")
                
        except Exception:
            pass
        
        # éªŒè¯äº‹åŠ¡å›æ»š
        content.refresh_from_db()
        self.assertEqual(content.play_count, 0)
        self.assertEqual(PlayHistory.objects.count(), 0)

    def test_concurrent_access(self):
        """æµ‹è¯•å¹¶å‘è®¿é—®"""
        import threading
        import time
        
        user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123'
        )
        
        artist = Artist.objects.create(name='Test Artist')
        
        content = AudioContent.objects.create(
            title='Test Audio',
            artist=artist,
            audio_url='https://example.com/audio.mp3',
            duration=180
        )
        
        def increment_play_count():
            for _ in range(10):
                content.increment_play_count()
                time.sleep(0.01)
        
        # åˆ›å»ºå¤šä¸ªçº¿ç¨‹åŒæ—¶å¢åŠ æ’­æ”¾æ¬¡æ•°
        threads = []
        for _ in range(5):
            thread = threading.Thread(target=increment_play_count)
            threads.append(thread)
            thread.start()
        
        # ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
        for thread in threads:
            thread.join()
        
        content.refresh_from_db()
        self.assertEqual(content.play_count, 50)
```

#### APIé›†æˆæµ‹è¯•
```python
# tests/integration/test_api_integration.py
import pytest
from django.test import TestCase
from rest_framework.test import APIClient
from rest_framework import status
from unittest.mock import patch
from apps.users.models import User

class APIIntegrationTest(TestCase):
    def setUp(self):
        self.client = APIClient()
        self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123'
        )

    def test_complete_user_journey(self):
        """æµ‹è¯•å®Œæ•´çš„ç”¨æˆ·ä½¿ç”¨æµç¨‹"""
        # 1. ç”¨æˆ·æ³¨å†Œ
        register_data = {
            'username': 'newuser',
            'email': 'newuser@example.com',
            'password': 'newpass123',
            'password_confirm': 'newpass123'
        }
        
        response = self.client.post('/api/v1/auth/register', register_data)
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        
        token = response.data['data']['token']['access']
        
        # 2. è·å–æ¨èå†…å®¹
        self.client.credentials(HTTP_AUTHORIZATION=f'Bearer {token}')
        response = self.client.get('/api/v1/content/recommend')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        
        recommended_content = response.data['data']['results'][0]
        content_id = recommended_content['id']
        
        # 3. æ’­æ”¾éŸ³é¢‘
        play_data = {
            'content_id': content_id,
            'device_type': 'mobile'
        }
        
        response = self.client.post('/api/v1/player/play', play_data)
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        
        # 4. æ”¶è—éŸ³é¢‘
        favorite_data = {
            'content_id': content_id,
            'content_type': 'audio'
        }
        
        response = self.client.post('/api/v1/user/favorites', favorite_data)
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        
        # 5. è·å–æ”¶è—åˆ—è¡¨
        response = self.client.get('/api/v1/user/favorites')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertGreater(len(response.data['data']['results']), 0)

    @patch('apps.ai.services.tts_service.synthesize')
    def test_ai_tts_integration(self, mock_tts):
        """æµ‹è¯•AI TTSé›†æˆ"""
        mock_tts.return_value = {
            'task_id': 'tts_12345',
            'status': 'completed',
            'audio_url': 'https://example.com/tts_audio.mp3'
        }
        
        # ç™»å½•
        login_data = {
            'login': 'testuser',
            'password': 'testpass123'
        }
        
        response = self.client.post('/api/v1/auth/login', login_data)
        token = response.data['data']['token']['access']
        
        # TTSè¯·æ±‚
        self.client.credentials(HTTP_AUTHORIZATION=f'Bearer {token}')
        tts_data = {
            'text': 'æ¬¢è¿ä½¿ç”¨ç¾Šå’©å¿«æŠ¥',
            'voice_type': 'standard_female',
            'speed': 1.0
        }
        
        response = self.client.post('/api/v1/ai/tts', tts_data)
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        
        task_id = response.data['data']['task_id']
        
        # æ£€æŸ¥TTSçŠ¶æ€
        response = self.client.get(f'/api/v1/ai/tts/{task_id}')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['data']['status'], 'completed')

    def test_search_integration(self):
        """æµ‹è¯•æœç´¢åŠŸèƒ½é›†æˆ"""
        # æœç´¢å»ºè®®
        response = self.client.get('/api/v1/ai/search/suggest', {'q': 'test'})
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        
        # æ‰§è¡Œæœç´¢
        response = self.client.get('/api/v1/content/search', {'q': 'test music'})
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        
        # éªŒè¯æœç´¢ç»“æœç»“æ„
        self.assertIn('results', response.data['data'])
        self.assertIn('pagination', response.data['data'])

    def test_error_handling_integration(self):
        """æµ‹è¯•é”™è¯¯å¤„ç†é›†æˆ"""
        # æµ‹è¯•æ— æ•ˆtoken
        self.client.credentials(HTTP_AUTHORIZATION='Bearer invalid_token')
        response = self.client.get('/api/v1/user/profile')
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
        
        # æµ‹è¯•èµ„æºä¸å­˜åœ¨
        response = self.client.get('/api/v1/content/99999')
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)
        
        # æµ‹è¯•è¯·æ±‚å‚æ•°é”™è¯¯
        response = self.client.post('/api/v1/auth/register', {})
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
```

---

## 3. å‰ç«¯æµ‹è¯• (UniApp)

### 3.1 ç»„ä»¶å•å…ƒæµ‹è¯•

#### Vueç»„ä»¶æµ‹è¯•
```javascript
// tests/unit/components/ContentCard.spec.js
import { mount } from '@vue/test-utils'
import { createPinia } from 'pinia'
import ContentCard from '@/components/content/ContentCard.vue'

describe('ContentCard.vue', () => {
  let wrapper
  let pinia

  const mockContent = {
    id: 1,
    title: 'Test Audio',
    artist: {
      id: 1,
      name: 'Test Artist'
    },
    cover_url: 'https://example.com/cover.jpg',
    duration: 180,
    play_count: 1000,
    is_liked: false
  }

  beforeEach(() => {
    pinia = createPinia()
    wrapper = mount(ContentCard, {
      global: {
        plugins: [pinia]
      },
      props: {
        content: mockContent,
        cardType: 'small'
      }
    })
  })

  afterEach(() => {
    wrapper.unmount()
  })

  it('renders content information correctly', () => {
    expect(wrapper.find('.card-title').text()).toBe('Test Audio')
    expect(wrapper.find('.card-artist').text()).toBe('Test Artist')
    expect(wrapper.find('.card-cover').attributes('src')).toBe('https://example.com/cover.jpg')
  })

  it('formats duration correctly', () => {
    const durationText = wrapper.find('.duration-label').text()
    expect(durationText).toBe('3:00')
  })

  it('emits click event when card is clicked', async () => {
    await wrapper.trigger('click')
    expect(wrapper.emitted('click')).toBeTruthy()
    expect(wrapper.emitted('click')[0][0]).toEqual(mockContent)
  })

  it('toggles like status when like button is clicked', async () => {
    const likeButton = wrapper.find('.like-button')
    await likeButton.trigger('click')
    
    expect(wrapper.emitted('like')).toBeTruthy()
    expect(wrapper.emitted('like')[0][0]).toEqual(mockContent)
  })

  it('applies correct card type class', () => {
    expect(wrapper.classes()).toContain('card-small')
  })

  it('shows play indicator when content is currently playing', async () => {
    // Mock store state
    const playerStore = usePlayerStore()
    playerStore.currentTrack = { id: 1 }
    playerStore.isPlaying = true

    await wrapper.vm.$nextTick()
    expect(wrapper.find('.play-indicator').exists()).toBe(true)
  })

  it('formats play count correctly', () => {
    const playCountText = wrapper.find('.play-count').text()
    expect(playCountText).toBe('1K æ¬¡æ’­æ”¾')
  })
})
```

#### Storeæµ‹è¯•
```javascript
// tests/unit/store/player.spec.js
import { setActivePinia, createPinia } from 'pinia'
import { usePlayerStore } from '@/store/modules/player'

describe('Player Store', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
  })

  it('initializes with default state', () => {
    const store = usePlayerStore()
    
    expect(store.currentTrack).toBe(null)
    expect(store.isPlaying).toBe(false)
    expect(store.currentTime).toBe(0)
    expect(store.duration).toBe(0)
    expect(store.volume).toBe(1.0)
    expect(store.shuffleMode).toBe(false)
    expect(store.repeatMode).toBe('none')
  })

  it('calculates progress percent correctly', () => {
    const store = usePlayerStore()
    store.currentTime = 90
    store.duration = 180
    
    expect(store.progressPercent).toBe(50)
  })

  it('handles play track action', async () => {
    const store = usePlayerStore()
    const mockTrack = {
      id: 1,
      title: 'Test Track',
      audio_url: 'https://example.com/audio.mp3',
      duration: 180
    }

    // Mock audio context
    global.uni = {
      createInnerAudioContext: jest.fn().mockReturnValue({
        play: jest.fn().mockResolvedValue(),
        onPlay: jest.fn(),
        onPause: jest.fn(),
        onTimeUpdate: jest.fn(),
        onEnded: jest.fn(),
        onError: jest.fn()
      })
    }

    await store.playTrack(mockTrack)
    
    expect(store.currentTrack).toEqual(mockTrack)
    expect(store.isLoading).toBe(false)
  })

  it('toggles play/pause correctly', async () => {
    const store = usePlayerStore()
    const mockAudioContext = {
      play: jest.fn().mockResolvedValue(),
      pause: jest.fn()
    }

    store.audioContext = mockAudioContext
    store.isPlaying = false

    await store.togglePlay()
    expect(mockAudioContext.play).toHaveBeenCalled()

    store.isPlaying = true
    await store.togglePlay()
    expect(mockAudioContext.pause).toHaveBeenCalled()
  })

  it('handles next track correctly in sequence mode', () => {
    const store = usePlayerStore()
    store.playQueue = [
      { id: 1, title: 'Track 1' },
      { id: 2, title: 'Track 2' },
      { id: 3, title: 'Track 3' }
    ]
    store.currentIndex = 0
    store.shuffleMode = false

    const nextIndex = store.getNextTrackIndex()
    expect(nextIndex).toBe(1)
  })

  it('handles next track correctly in shuffle mode', () => {
    const store = usePlayerStore()
    store.playQueue = [
      { id: 1, title: 'Track 1' },
      { id: 2, title: 'Track 2' },
      { id: 3, title: 'Track 3' }
    ]
    store.currentIndex = 0
    store.shuffleMode = true

    const nextIndex = store.getNextTrackIndex()
    expect(nextIndex).toBeGreaterThanOrEqual(0)
    expect(nextIndex).toBeLessThan(store.playQueue.length)
    expect(nextIndex).not.toBe(0) // ä¸åº”è¯¥æ˜¯å½“å‰ç´¢å¼•
  })

  it('handles repeat modes correctly', () => {
    const store = usePlayerStore()
    
    // æµ‹è¯•é‡å¤æ¨¡å¼åˆ‡æ¢
    expect(store.repeatMode).toBe('none')
    
    store.toggleRepeat()
    expect(store.repeatMode).toBe('one')
    
    store.toggleRepeat()
    expect(store.repeatMode).toBe('all')
    
    store.toggleRepeat()
    expect(store.repeatMode).toBe('none')
  })

  it('records play history correctly', () => {
    const store = usePlayerStore()
    const mockTrack = {
      id: 1,
      title: 'Test Track'
    }

    store.addToHistory(mockTrack)
    
    expect(store.playHistory).toHaveLength(1)
    expect(store.playHistory[0].id).toBe(1)
    expect(store.playHistory[0].playedAt).toBeDefined()
  })

  it('limits play history size', () => {
    const store = usePlayerStore()
    
    // æ·»åŠ è¶…è¿‡é™åˆ¶çš„å†å²è®°å½•
    for (let i = 0; i < 1005; i++) {
      store.addToHistory({
        id: i,
        title: `Track ${i}`
      })
    }
    
    expect(store.playHistory).toHaveLength(1000)
  })
})
```

### 3.2 é›†æˆæµ‹è¯•

#### é¡µé¢é›†æˆæµ‹è¯•
```javascript
// tests/integration/pages/Index.spec.js
import { mount } from '@vue/test-utils'
import { createPinia } from 'pinia'
import IndexPage from '@/pages/index/index.vue'
import * as api from '@/api'

// Mock API calls
jest.mock('@/api', () => ({
  content: {
    getRecommended: jest.fn(),
    getByCategory: jest.fn()
  },
  user: {
    getProfile: jest.fn()
  }
}))

describe('Index Page Integration', () => {
  let wrapper
  let pinia

  beforeEach(() => {
    pinia = createPinia()
    
    // Mock API responses
    api.content.getRecommended.mockResolvedValue({
      success: true,
      data: {
        results: [
          {
            id: 1,
            title: 'Test Audio 1',
            artist: { name: 'Artist 1' },
            cover_url: 'https://example.com/cover1.jpg'
          },
          {
            id: 2,
            title: 'Test Audio 2',
            artist: { name: 'Artist 2' },
            cover_url: 'https://example.com/cover2.jpg'
          }
        ]
      }
    })

    api.user.getProfile.mockResolvedValue({
      success: true,
      data: {
        nickname: 'Test User'
      }
    })

    wrapper = mount(IndexPage, {
      global: {
        plugins: [pinia],
        mocks: {
          $router: {
            push: jest.fn()
          }
        }
      }
    })
  })

  afterEach(() => {
    wrapper.unmount()
    jest.clearAllMocks()
  })

  it('loads and displays recommended content', async () => {
    await wrapper.vm.$nextTick()
    await new Promise(resolve => setTimeout(resolve, 0))

    expect(api.content.getRecommended).toHaveBeenCalled()
    
    const contentCards = wrapper.findAllComponents({ name: 'ContentCard' })
    expect(contentCards).toHaveLength(2)
  })

  it('displays greeting with user name', async () => {
    const userStore = useUserStore()
    userStore.userInfo = { nickname: 'Test User' }

    await wrapper.vm.$nextTick()

    const greeting = wrapper.find('.greeting-text')
    expect(greeting.text()).toContain('Test User')
  })

  it('handles category selection', async () => {
    const categoryItems = wrapper.findAll('.category-item')
    
    await categoryItems[1].trigger('click')
    
    expect(api.content.getByCategory).toHaveBeenCalledWith(
      expect.objectContaining({
        category_id: expect.any(Number)
      })
    )
  })

  it('navigates to search page when search icon is clicked', async () => {
    const searchIcon = wrapper.find('[name="search"]')
    await searchIcon.trigger('click')

    expect(wrapper.vm.$router.push).toHaveBeenCalledWith('/pages/discover/search')
  })

  it('plays content when content card is clicked', async () => {
    await wrapper.vm.$nextTick()
    
    const playerStore = usePlayerStore()
    const playTrackSpy = jest.spyOn(playerStore, 'playTrack')

    const contentCard = wrapper.findComponent({ name: 'ContentCard' })
    await contentCard.trigger('click')

    expect(playTrackSpy).toHaveBeenCalled()
  })

  it('handles loading states correctly', async () => {
    // Initial loading state
    expect(wrapper.find('.loading').exists()).toBe(true)

    await wrapper.vm.$nextTick()
    await new Promise(resolve => setTimeout(resolve, 0))

    // Loading should be hidden after data loads
    expect(wrapper.find('.loading').exists()).toBe(false)
  })

  it('handles error states correctly', async () => {
    // Mock API error
    api.content.getRecommended.mockRejectedValue(new Error('Network error'))

    const newWrapper = mount(IndexPage, {
      global: {
        plugins: [pinia]
      }
    })

    await newWrapper.vm.$nextTick()
    await new Promise(resolve => setTimeout(resolve, 0))

    expect(newWrapper.find('.error-message').exists()).toBe(true)
    
    newWrapper.unmount()
  })
})
```

#### æ’­æ”¾å™¨é›†æˆæµ‹è¯•
```javascript
// tests/integration/player/PlayerIntegration.spec.js
import { mount } from '@vue/test-utils'
import { createPinia } from 'pinia'
import PlayerPage from '@/pages/player/player.vue'
import MiniPlayer from '@/components/player/MiniPlayer.vue'

describe('Player Integration', () => {
  let wrapper
  let pinia
  let playerStore

  const mockTrack = {
    id: 1,
    title: 'Test Track',
    artist: { name: 'Test Artist' },
    cover_url: 'https://example.com/cover.jpg',
    audio_url: 'https://example.com/audio.mp3',
    duration: 180
  }

  beforeEach(() => {
    pinia = createPinia()
    playerStore = usePlayerStore()
    
    // Mock audio context
    global.uni = {
      createInnerAudioContext: jest.fn().mockReturnValue({
        play: jest.fn().mockResolvedValue(),
        pause: jest.fn(),
        stop: jest.fn(),
        seek: jest.fn(),
        destroy: jest.fn(),
        onPlay: jest.fn(),
        onPause: jest.fn(),
        onTimeUpdate: jest.fn(),
        onEnded: jest.fn(),
        onError: jest.fn(),
        currentTime: 0,
        duration: 180,
        volume: 1
      })
    }

    playerStore.currentTrack = mockTrack
    playerStore.isPlaying = false

    wrapper = mount(PlayerPage, {
      global: {
        plugins: [pinia]
      }
    })
  })

  afterEach(() => {
    wrapper.unmount()
  })

  it('displays current track information', () => {
    expect(wrapper.find('.track-title').text()).toBe('Test Track')
    expect(wrapper.find('.track-artist').text()).toBe('Test Artist')
    expect(wrapper.find('.cover-image').attributes('src')).toBe('https://example.com/cover.jpg')
  })

  it('toggles play/pause when play button is clicked', async () => {
    const playButton = wrapper.find('.play-button')
    const togglePlaySpy = jest.spyOn(playerStore, 'togglePlay')

    await playButton.trigger('click')
    expect(togglePlaySpy).toHaveBeenCalled()
  })

  it('seeks to correct position when progress bar is clicked', async () => {
    const progressBar = wrapper.find('.progress-section')
    const seekSpy = jest.spyOn(playerStore, 'seek')

    // Mock getBoundingClientRect
    progressBar.element.getBoundingClientRect = jest.fn().mockReturnValue({
      left: 0,
      width: 100
    })

    await progressBar.trigger('click', { clientX: 50 })
    expect(seekSpy).toHaveBeenCalledWith(90) // 50% of 180 seconds
  })

  it('plays next track when next button is clicked', async () => {
    const nextButton = wrapper.find('[name="skip-next"]')
    const playNextSpy = jest.spyOn(playerStore, 'playNext')

    await nextButton.trigger('click')
    expect(playNextSpy).toHaveBeenCalled()
  })

  it('plays previous track when previous button is clicked', async () => {
    const prevButton = wrapper.find('[name="skip-previous"]')
    const playPreviousSpy = jest.spyOn(playerStore, 'playPrevious')

    await prevButton.trigger('click')
    expect(playPreviousSpy).toHaveBeenCalled()
  })

  it('updates UI when playback state changes', async () => {
    // Initially not playing
    expect(wrapper.find('[name="play"]').exists()).toBe(true)
    expect(wrapper.find('[name="pause"]').exists()).toBe(false)

    // Change to playing state
    playerStore.isPlaying = true
    await wrapper.vm.$nextTick()

    expect(wrapper.find('[name="play"]').exists()).toBe(false)
    expect(wrapper.find('[name="pause"]').exists()).toBe(true)
  })

  it('updates progress display during playback', async () => {
    playerStore.currentTime = 90
    playerStore.duration = 180
    await wrapper.vm.$nextTick()

    expect(wrapper.find('.time-text').at(0).text()).toBe('1:30')
    expect(wrapper.find('.time-text').at(1).text()).toBe('3:00')
  })

  it('integrates with mini player correctly', async () => {
    const miniPlayer = mount(MiniPlayer, {
      global: {
        plugins: [pinia]
      }
    })

    expect(miniPlayer.find('.track-title').text()).toBe('Test Track')
    expect(miniPlayer.find('.track-artist').text()).toBe('Test Artist')

    // Click mini player to navigate to full player
    const navigateSpy = jest.spyOn(uni, 'navigateTo')
    await miniPlayer.trigger('click')

    expect(navigateSpy).toHaveBeenCalledWith({
      url: '/pages/player/player'
    })

    miniPlayer.unmount()
  })
})
```

---

## 4. æ€§èƒ½æµ‹è¯•

### 4.1 è´Ÿè½½æµ‹è¯•

#### APIè´Ÿè½½æµ‹è¯•è„šæœ¬
```javascript
// tests/performance/load-test.js
import http from 'k6/http'
import { check, sleep } from 'k6'
import { Rate } from 'k6/metrics'

export let errorRate = new Rate('errors')

export let options = {
  stages: [
    { duration: '2m', target: 100 }, // 2åˆ†é’Ÿå†…å¢åŠ åˆ°100ç”¨æˆ·
    { duration: '5m', target: 100 }, // ä¿æŒ100ç”¨æˆ·5åˆ†é’Ÿ
    { duration: '2m', target: 200 }, // 2åˆ†é’Ÿå†…å¢åŠ åˆ°200ç”¨æˆ·
    { duration: '5m', target: 200 }, // ä¿æŒ200ç”¨æˆ·5åˆ†é’Ÿ
    { duration: '2m', target: 0 },   // 2åˆ†é’Ÿå†…å‡å°‘åˆ°0ç”¨æˆ·
  ],
  thresholds: {
    http_req_duration: ['p(99)<1500'], // 99%çš„è¯·æ±‚åœ¨1.5ç§’å†…å®Œæˆ
    http_req_failed: ['rate<0.1'],     // é”™è¯¯ç‡ä½äº10%
    errors: ['rate<0.1'],
  },
}

const BASE_URL = 'https://api.yangmie.com/v1'

// æ¨¡æ‹Ÿç”¨æˆ·ç™»å½•è·å–token
function getAuthToken() {
  const loginData = {
    login: 'testuser',
    password: 'testpass123'
  }

  const response = http.post(`${BASE_URL}/auth/login`, JSON.stringify(loginData), {
    headers: { 'Content-Type': 'application/json' }
  })

  const success = check(response, {
    'login successful': (r) => r.status === 200,
    'login response has token': (r) => r.json('data.token.access') !== undefined
  })

  if (success) {
    return response.json('data.token.access')
  }
  return null
}

export default function () {
  // 1. æµ‹è¯•é¦–é¡µæ¨èå†…å®¹API
  let response = http.get(`${BASE_URL}/content/recommend`)
  
  let success = check(response, {
    'recommend status is 200': (r) => r.status === 200,
    'recommend has results': (r) => r.json('data.results.length') > 0,
    'recommend response time < 500ms': (r) => r.timings.duration < 500
  })
  
  errorRate.add(!success)

  // 2. æµ‹è¯•æœç´¢API
  response = http.get(`${BASE_URL}/content/search?q=test&page=1&page_size=20`)
  
  success = check(response, {
    'search status is 200': (r) => r.status === 200,
    'search has pagination': (r) => r.json('data.pagination') !== undefined,
    'search response time < 800ms': (r) => r.timings.duration < 800
  })
  
  errorRate.add(!success)

  // 3. è·å–è®¤è¯tokenå¹¶æµ‹è¯•éœ€è¦è®¤è¯çš„API
  const token = getAuthToken()
  
  if (token) {
    const headers = {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    }

    // æµ‹è¯•ç”¨æˆ·èµ„æ–™API
    response = http.get(`${BASE_URL}/users/profile`, { headers })
    
    success = check(response, {
      'profile status is 200': (r) => r.status === 200,
      'profile has user data': (r) => r.json('data.id') !== undefined
    })
    
    errorRate.add(!success)

    // æµ‹è¯•æ’­æ”¾è®°å½•API
    const playData = {
      content_id: 1,
      play_duration: 120,
      completion_rate: 66.67,
      device_type: 'mobile'
    }

    response = http.post(`${BASE_URL}/player/play`, JSON.stringify(playData), { headers })
    
    success = check(response, {
      'play record status is 201': (r) => r.status === 201
    })
    
    errorRate.add(!success)
  }

  sleep(1) // ç”¨æˆ·æ“ä½œé—´éš”
}

// æ€§èƒ½æµ‹è¯•æŠ¥å‘Š
export function handleSummary(data) {
  return {
    'performance-report.html': htmlReport(data),
    'performance-summary.json': JSON.stringify(data, null, 2)
  }
}

function htmlReport(data) {
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <title>ç¾Šå’©å¿«æŠ¥ - æ€§èƒ½æµ‹è¯•æŠ¥å‘Š</title>
      <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .metric { background: #f5f5f5; padding: 10px; margin: 10px 0; border-radius: 5px; }
        .pass { color: green; }
        .fail { color: red; }
      </style>
    </head>
    <body>
      <h1>ç¾Šå’©å¿«æŠ¥ - æ€§èƒ½æµ‹è¯•æŠ¥å‘Š</h1>
      
      <h2>æµ‹è¯•æ¦‚å†µ</h2>
      <div class="metric">
        <strong>æµ‹è¯•æ—¶é•¿:</strong> ${data.state.testRunDurationMs / 1000}ç§’<br>
        <strong>è™šæ‹Ÿç”¨æˆ·æ•°:</strong> ${data.metrics.vus.values.max}<br>
        <strong>è¯·æ±‚æ€»æ•°:</strong> ${data.metrics.http_reqs.values.count}<br>
        <strong>é”™è¯¯ç‡:</strong> ${(data.metrics.http_req_failed.values.rate * 100).toFixed(2)}%
      </div>

      <h2>å“åº”æ—¶é—´</h2>
      <div class="metric">
        <strong>å¹³å‡å“åº”æ—¶é—´:</strong> ${data.metrics.http_req_duration.values.avg.toFixed(2)}ms<br>
        <strong>95%åˆ†ä½:</strong> ${data.metrics.http_req_duration.values['p(95)'].toFixed(2)}ms<br>
        <strong>99%åˆ†ä½:</strong> ${data.metrics.http_req_duration.values['p(99)'].toFixed(2)}ms
      </div>

      <h2>é˜ˆå€¼æ£€æŸ¥</h2>
      ${Object.entries(data.thresholds).map(([name, threshold]) => `
        <div class="metric ${threshold.ok ? 'pass' : 'fail'}">
          <strong>${name}:</strong> ${threshold.ok ? 'é€šè¿‡' : 'å¤±è´¥'}
        </div>
      `).join('')}
    </body>
    </html>
  `
}
```

### 4.2 å‰ç«¯æ€§èƒ½æµ‹è¯•

#### Lighthouseè‡ªåŠ¨åŒ–æµ‹è¯•
```javascript
// tests/performance/lighthouse-test.js
const lighthouse = require('lighthouse')
const chromeLauncher = require('chrome-launcher')
const fs = require('fs')

async function runLighthouseTest() {
  const chrome = await chromeLauncher.launch({ chromeFlags: ['--headless'] })
  
  const options = {
    logLevel: 'info',
    output: 'html',
    onlyCategories: ['performance', 'accessibility', 'best-practices', 'seo'],
    port: chrome.port
  }

  // æµ‹è¯•ä¸åŒé¡µé¢
  const pages = [
    { name: 'Home', url: 'https://yangmie.com' },
    { name: 'Search', url: 'https://yangmie.com/search' },
    { name: 'Player', url: 'https://yangmie.com/player' }
  ]

  const results = []

  for (const page of pages) {
    console.log(`Testing ${page.name} page...`)
    
    const runnerResult = await lighthouse(page.url, options)
    const reportHtml = runnerResult.report
    
    // ä¿å­˜è¯¦ç»†æŠ¥å‘Š
    fs.writeFileSync(`lighthouse-${page.name.toLowerCase()}.html`, reportHtml)
    
    // æå–å…³é”®æŒ‡æ ‡
    const { lhr } = runnerResult
    const metrics = {
      page: page.name,
      performance: lhr.categories.performance.score * 100,
      accessibility: lhr.categories.accessibility.score * 100,
      bestPractices: lhr.categories['best-practices'].score * 100,
      seo: lhr.categories.seo.score * 100,
      firstContentfulPaint: lhr.audits['first-contentful-paint'].numericValue,
      largestContentfulPaint: lhr.audits['largest-contentful-paint'].numericValue,
      cumulativeLayoutShift: lhr.audits['cumulative-layout-shift'].numericValue,
      totalBlockingTime: lhr.audits['total-blocking-time'].numericValue
    }
    
    results.push(metrics)
    
    // æ€§èƒ½é˜ˆå€¼æ£€æŸ¥
    const performanceThresholds = {
      performance: 90,
      accessibility: 95,
      firstContentfulPaint: 1500,
      largestContentfulPaint: 2500,
      cumulativeLayoutShift: 0.1
    }
    
    console.log(`${page.name} Performance Score: ${metrics.performance}`)
    console.log(`${page.name} Accessibility Score: ${metrics.accessibility}`)
    
    if (metrics.performance < performanceThresholds.performance) {
      console.warn(`âš ï¸  ${page.name} performance score below threshold!`)
    }
    
    if (metrics.firstContentfulPaint > performanceThresholds.firstContentfulPaint) {
      console.warn(`âš ï¸  ${page.name} FCP too slow!`)
    }
  }

  await chrome.kill()
  
  // ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
  generatePerformanceReport(results)
  
  return results
}

function generatePerformanceReport(results) {
  const report = {
    timestamp: new Date().toISOString(),
    summary: {
      averagePerformance: results.reduce((sum, r) => sum + r.performance, 0) / results.length,
      averageAccessibility: results.reduce((sum, r) => sum + r.accessibility, 0) / results.length,
      averageFCP: results.reduce((sum, r) => sum + r.firstContentfulPaint, 0) / results.length,
      averageLCP: results.reduce((sum, r) => sum + r.largestContentfulPaint, 0) / results.length
    },
    details: results
  }

  fs.writeFileSync('performance-report.json', JSON.stringify(report, null, 2))
  
  console.log('\nğŸ“Š Performance Report Generated:')
  console.log(`Average Performance Score: ${report.summary.averagePerformance.toFixed(1)}`)
  console.log(`Average Accessibility Score: ${report.summary.averageAccessibility.toFixed(1)}`)
  console.log(`Average FCP: ${report.summary.averageFCP.toFixed(0)}ms`)
  console.log(`Average LCP: ${report.summary.averageLCP.toFixed(0)}ms`)
}

// è¿è¡Œæµ‹è¯•
if (require.main === module) {
  runLighthouseTest().catch(console.error)
}

module.exports = { runLighthouseTest }
```

---

## 5. ç«¯åˆ°ç«¯æµ‹è¯• (E2E)

### 5.1 ç”¨æˆ·æµç¨‹æµ‹è¯•

#### Cypress E2Eæµ‹è¯•
```javascript
// cypress/integration/user-journey.spec.js
describe('ç¾Šå’©å¿«æŠ¥ - å®Œæ•´ç”¨æˆ·æµç¨‹', () => {
  beforeEach(() => {
    // æ¸…ç†cookieså’ŒlocalStorage
    cy.clearCookies()
    cy.clearLocalStorage()
    
    // è®¿é—®é¦–é¡µ
    cy.visit('/')
  })

  it('æ–°ç”¨æˆ·æ³¨å†Œåˆ°æ’­æ”¾éŸ³ä¹çš„å®Œæ•´æµç¨‹', () => {
    // 1. ç‚¹å‡»æ³¨å†Œ
    cy.contains('æ³¨å†Œ').click()
    
    // 2. å¡«å†™æ³¨å†Œä¿¡æ¯
    cy.get('[data-cy="username"]').type('newuser123')
    cy.get('[data-cy="email"]').type('newuser@example.com')
    cy.get('[data-cy="password"]').type('password123')
    cy.get('[data-cy="password-confirm"]').type('password123')
    
    // 3. æäº¤æ³¨å†Œ
    cy.get('[data-cy="register-submit"]').click()
    
    // 4. éªŒè¯æ³¨å†ŒæˆåŠŸï¼Œè·³è½¬åˆ°é¦–é¡µ
    cy.url().should('include', '/pages/index/index')
    cy.contains('Good Morning').should('be.visible')
    
    // 5. æµè§ˆæ¨èå†…å®¹
    cy.get('[data-cy="content-card"]').should('have.length.greaterThan', 0)
    
    // 6. ç‚¹å‡»æ’­æ”¾ç¬¬ä¸€é¦–éŸ³ä¹
    cy.get('[data-cy="content-card"]').first().click()
    
    // 7. éªŒè¯æ’­æ”¾å™¨å¯åŠ¨
    cy.get('[data-cy="mini-player"]').should('be.visible')
    cy.get('[data-cy="play-button"]').should('contain', 'pause')
    
    // 8. æ‰“å¼€å…¨å±æ’­æ”¾å™¨
    cy.get('[data-cy="mini-player"]').click()
    cy.url().should('include', '/pages/player/player')
    
    // 9. æµ‹è¯•æ’­æ”¾æ§åˆ¶
    cy.get('[data-cy="pause-button"]').click()
    cy.get('[data-cy="play-button"]').should('be.visible')
    
    // 10. æ”¶è—å½“å‰æ­Œæ›²
    cy.get('[data-cy="favorite-button"]').click()
    cy.get('[data-cy="favorite-button"]').should('have.class', 'favorited')
    
    // 11. è¿”å›é¦–é¡µ
    cy.get('[data-cy="back-button"]').click()
    
    // 12. æŸ¥çœ‹æ”¶è—åˆ—è¡¨
    cy.get('[data-cy="tab-library"]').click()
    cy.get('[data-cy="favorites-section"]').click()
    cy.get('[data-cy="favorite-item"]').should('have.length', 1)
  })

  it('æœç´¢å’Œæ’­æ”¾éŸ³ä¹æµç¨‹', () => {
    // 1. ç‚¹å‡»æœç´¢
    cy.get('[data-cy="search-button"]').click()
    
    // 2. è¾“å…¥æœç´¢å…³é”®è¯
    cy.get('[data-cy="search-input"]').type('test music')
    
    // 3. æŸ¥çœ‹æœç´¢å»ºè®®
    cy.get('[data-cy="search-suggestion"]').should('be.visible')
    cy.get('[data-cy="search-suggestion"]').first().click()
    
    // 4. æŸ¥çœ‹æœç´¢ç»“æœ
    cy.get('[data-cy="search-result"]').should('have.length.greaterThan', 0)
    
    // 5. ç­›é€‰ç»“æœ
    cy.get('[data-cy="filter-tab-songs"]').click()
    cy.get('[data-cy="search-result"]').should('have.length.greaterThan', 0)
    
    // 6. æ’­æ”¾æœç´¢ç»“æœ
    cy.get('[data-cy="search-result"]').first().click()
    cy.get('[data-cy="mini-player"]').should('be.visible')
  })

  it('åˆ›å»ºå’Œç®¡ç†æ’­æ”¾åˆ—è¡¨æµç¨‹', () => {
    // 1. ç™»å½•ï¼ˆå‡è®¾å·²æœ‰ç”¨æˆ·ï¼‰
    cy.login('testuser', 'testpass123')
    
    // 2. è¿›å…¥éŸ³ä¹åº“
    cy.get('[data-cy="tab-library"]').click()
    
    // 3. åˆ›å»ºæ–°æ’­æ”¾åˆ—è¡¨
    cy.get('[data-cy="create-playlist"]').click()
    cy.get('[data-cy="playlist-name"]').type('æˆ‘çš„æµ‹è¯•æ’­æ”¾åˆ—è¡¨')
    cy.get('[data-cy="playlist-description"]').type('æµ‹è¯•æ’­æ”¾åˆ—è¡¨æè¿°')
    cy.get('[data-cy="create-playlist-submit"]').click()
    
    // 4. éªŒè¯æ’­æ”¾åˆ—è¡¨åˆ›å»ºæˆåŠŸ
    cy.contains('æˆ‘çš„æµ‹è¯•æ’­æ”¾åˆ—è¡¨').should('be.visible')
    
    // 5. æ·»åŠ æ­Œæ›²åˆ°æ’­æ”¾åˆ—è¡¨
    cy.visit('/pages/index/index')
    cy.get('[data-cy="content-card"]').first().within(() => {
      cy.get('[data-cy="more-button"]').click()
    })
    cy.get('[data-cy="add-to-playlist"]').click()
    cy.contains('æˆ‘çš„æµ‹è¯•æ’­æ”¾åˆ—è¡¨').click()
    
    // 6. éªŒè¯æ­Œæ›²æ·»åŠ æˆåŠŸ
    cy.get('[data-cy="toast"]').should('contain', 'æ·»åŠ æˆåŠŸ')
    
    // 7. æŸ¥çœ‹æ’­æ”¾åˆ—è¡¨å†…å®¹
    cy.get('[data-cy="tab-library"]').click()
    cy.contains('æˆ‘çš„æµ‹è¯•æ’­æ”¾åˆ—è¡¨').click()
    cy.get('[data-cy="playlist-track"]').should('have.length', 1)
  })

  it('è¯­éŸ³æœç´¢åŠŸèƒ½æµ‹è¯•', () => {
    // 1. è¿›å…¥æœç´¢é¡µé¢
    cy.get('[data-cy="search-button"]').click()
    
    // 2. ç‚¹å‡»è¯­éŸ³æœç´¢æŒ‰é’®
    cy.get('[data-cy="voice-search"]').click()
    
    // 3. æ¨¡æ‹Ÿè¯­éŸ³è¾“å…¥
    cy.window().then((win) => {
      // æ¨¡æ‹Ÿè¯­éŸ³è¯†åˆ«ç»“æœ
      win.mockVoiceInput('æ’­æ”¾æµè¡ŒéŸ³ä¹')
    })
    
    // 4. éªŒè¯è¯­éŸ³æŒ‡ä»¤æ‰§è¡Œ
    cy.get('[data-cy="search-input"]').should('have.value', 'æµè¡ŒéŸ³ä¹')
    cy.get('[data-cy="search-result"]').should('be.visible')
  })

  it('è®¾ç½®å’Œåå¥½é…ç½®æµ‹è¯•', () => {
    // 1. ç™»å½•
    cy.login('testuser', 'testpass123')
    
    // 2. è¿›å…¥ä¸ªäººä¸­å¿ƒ
    cy.get('[data-cy="tab-profile"]').click()
    
    // 3. æ‰“å¼€è®¾ç½®
    cy.get('[data-cy="settings-button"]').click()
    
    // 4. ä¿®æ”¹éŸ³é¢‘è´¨é‡è®¾ç½®
    cy.get('[data-cy="audio-quality"]').select('high')
    
    // 5. å¼€å¯è‡ªåŠ¨æ’­æ”¾
    cy.get('[data-cy="auto-play-toggle"]').click()
    
    // 6. ä¿®æ”¹ä¸»é¢˜è®¾ç½®
    cy.get('[data-cy="theme-selector"]').select('dark')
    
    // 7. ä¿å­˜è®¾ç½®
    cy.get('[data-cy="save-settings"]').click()
    cy.get('[data-cy="toast"]').should('contain', 'è®¾ç½®ä¿å­˜æˆåŠŸ')
    
    // 8. éªŒè¯è®¾ç½®ç”Ÿæ•ˆ
    cy.get('body').should('have.class', 'dark-theme')
  })
})

// è‡ªå®šä¹‰å‘½ä»¤
Cypress.Commands.add('login', (username, password) => {
  cy.get('[data-cy="login-button"]').click()
  cy.get('[data-cy="login-username"]').type(username)
  cy.get('[data-cy="login-password"]').type(password)
  cy.get('[data-cy="login-submit"]').click()
  cy.url().should('include', '/pages/index/index')
})

Cypress.Commands.add('mockVoiceInput', (text) => {
  cy.window().its('voiceCommandManager').then((manager) => {
    manager.handleRecognitionResult({
      transcript: text,
      isFinal: true
    })
  })
})
```

### 5.2 è·¨å¹³å°å…¼å®¹æ€§æµ‹è¯•

#### å¤šç«¯æµ‹è¯•é…ç½®
```javascript
// cypress/support/commands.js

// æ¨¡æ‹Ÿä¸åŒè®¾å¤‡
Cypress.Commands.add('setDevice', (device) => {
  const devices = {
    'iphone-x': { width: 375, height: 812, userAgent: 'iPhone' },
    'ipad': { width: 768, height: 1024, userAgent: 'iPad' },
    'android': { width: 360, height: 640, userAgent: 'Android' },
    'desktop': { width: 1920, height: 1080, userAgent: 'Chrome' }
  }
  
  const config = devices[device]
  if (config) {
    cy.viewport(config.width, config.height)
    cy.window().then((win) => {
      Object.defineProperty(win.navigator, 'userAgent', {
        value: config.userAgent,
        configurable: true
      })
    })
  }
})

// æµ‹è¯•å“åº”å¼å¸ƒå±€
Cypress.Commands.add('testResponsive', () => {
  const viewports = [
    { width: 320, height: 568 },  // iPhone SE
    { width: 375, height: 812 },  // iPhone X
    { width: 768, height: 1024 }, // iPad
    { width: 1920, height: 1080 } // Desktop
  ]
  
  viewports.forEach((viewport) => {
    cy.viewport(viewport.width, viewport.height)
    cy.get('[data-cy="main-content"]').should('be.visible')
    cy.get('[data-cy="navigation"]').should('be.visible')
  })
})
```

---

## 6. æµ‹è¯•è‡ªåŠ¨åŒ–æµç¨‹

### 6.1 CI/CDé›†æˆ

#### GitHub Actionsé…ç½®
```yaml
# .github/workflows/test.yml
name: ç¾Šå’©å¿«æŠ¥æµ‹è¯•æµç¨‹

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  backend-tests:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: yangmie_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      redis:
        image: redis:6
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: Install dependencies
      run: |
        cd backend
        pip install -r requirements/test.txt
    
    - name: Run linting
      run: |
        cd backend
        flake8 .
        black --check .
        isort --check-only .
    
    - name: Run unit tests
      run: |
        cd backend
        python manage.py test --settings=yangmie.settings.testing
      env:
        DATABASE_URL: postgres://postgres:postgres@localhost:5432/yangmie_test
        REDIS_URL: redis://localhost:6379/0
    
    - name: Run integration tests
      run: |
        cd backend
        pytest tests/integration/ -v
      env:
        DATABASE_URL: postgres://postgres:postgres@localhost:5432/yangmie_test
        REDIS_URL: redis://localhost:6379/0
    
    - name: Generate coverage report
      run: |
        cd backend
        coverage run --source='.' manage.py test
        coverage xml
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./backend/coverage.xml

  frontend-tests:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '16'
        cache: 'npm'
    
    - name: Install dependencies
      run: |
        cd frontend
        npm ci
    
    - name: Run linting
      run: |
        cd frontend
        npm run lint
    
    - name: Run unit tests
      run: |
        cd frontend
        npm run test:unit
    
    - name: Run integration tests
      run: |
        cd frontend
        npm run test:integration
    
    - name: Build application
      run: |
        cd frontend
        npm run build

  e2e-tests:
    runs-on: ubuntu-latest
    needs: [backend-tests, frontend-tests]
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '16'
        cache: 'npm'
    
    - name: Install dependencies
      run: |
        cd frontend
        npm ci
    
    - name: Start test environment
      run: |
        cd frontend
        npm run start:test &
        sleep 30
    
    - name: Run E2E tests
      run: |
        cd frontend
        npm run test:e2e:headless
    
    - name: Upload test artifacts
      uses: actions/upload-artifact@v3
      if: failure()
      with:
        name: cypress-screenshots
        path: frontend/cypress/screenshots

  performance-tests:
    runs-on: ubuntu-latest
    needs: [backend-tests, frontend-tests]
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '16'
        cache: 'npm'
    
    - name: Install k6
      run: |
        sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
        echo "deb https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
        sudo apt-get update
        sudo apt-get install k6
    
    - name: Run load tests
      run: |
        k6 run tests/performance/load-test.js
    
    - name: Run Lighthouse tests
      run: |
        npm install -g lighthouse
        cd tests/performance
        node lighthouse-test.js
    
    - name: Upload performance reports
      uses: actions/upload-artifact@v3
      with:
        name: performance-reports
        path: |
          lighthouse-*.html
          performance-report.json

  security-scan:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Run security scan
      uses: securecodewarrior/github-action-add-sarif@v1
      with:
        sarif-file: security-scan-results.sarif
    
    - name: Run dependency check
      run: |
        cd backend
        pip install safety
        safety check
        
        cd ../frontend
        npm audit --audit-level moderate
```

### 6.2 æµ‹è¯•æŠ¥å‘Šå’Œç›‘æ§

#### æµ‹è¯•æŠ¥å‘Šç”Ÿæˆ
```javascript
// scripts/generate-test-report.js
const fs = require('fs')
const path = require('path')

class TestReportGenerator {
  constructor() {
    this.results = {
      backend: {
        unit: null,
        integration: null,
        coverage: null
      },
      frontend: {
        unit: null,
        integration: null,
        e2e: null
      },
      performance: {
        load: null,
        lighthouse: null
      }
    }
  }

  async generateReport() {
    try {
      await this.collectTestResults()
      await this.generateHTMLReport()
      await this.generateSlackReport()
      await this.uploadToS3()
    } catch (error) {
      console.error('ç”Ÿæˆæµ‹è¯•æŠ¥å‘Šå¤±è´¥:', error)
    }
  }

  async collectTestResults() {
    // æ”¶é›†åç«¯æµ‹è¯•ç»“æœ
    if (fs.existsSync('backend/test-results.xml')) {
      this.results.backend.unit = this.parseJUnitXML('backend/test-results.xml')
    }

    // æ”¶é›†å‰ç«¯æµ‹è¯•ç»“æœ
    if (fs.existsSync('frontend/test-results.json')) {
      this.results.frontend.unit = JSON.parse(
        fs.readFileSync('frontend/test-results.json', 'utf8')
      )
    }

    // æ”¶é›†æ€§èƒ½æµ‹è¯•ç»“æœ
    if (fs.existsSync('performance-report.json')) {
      this.results.performance.lighthouse = JSON.parse(
        fs.readFileSync('performance-report.json', 'utf8')
      )
    }
  }

  async generateHTMLReport() {
    const template = this.getHTMLTemplate()
    const html = this.populateTemplate(template, this.results)
    
    fs.writeFileSync('test-report.html', html)
    console.log('âœ… HTMLæµ‹è¯•æŠ¥å‘Šå·²ç”Ÿæˆ: test-report.html')
  }

  getHTMLTemplate() {
    return `
    <!DOCTYPE html>
    <html>
    <head>
      <title>ç¾Šå’©å¿«æŠ¥ - æµ‹è¯•æŠ¥å‘Š</title>
      <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { background: #4CD964; color: white; padding: 20px; border-radius: 8px; }
        .section { margin: 20px 0; padding: 20px; border: 1px solid #ddd; border-radius: 8px; }
        .pass { color: #4CD964; }
        .fail { color: #ff3b30; }
        .metric { display: flex; justify-content: space-between; margin: 10px 0; }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }
        th { background-color: #f5f5f5; }
      </style>
    </head>
    <body>
      <div class="header">
        <h1>ç¾Šå’©å¿«æŠ¥ - æµ‹è¯•æŠ¥å‘Š</h1>
        <p>ç”Ÿæˆæ—¶é—´: {{timestamp}}</p>
        <p>æ€»ä½“çŠ¶æ€: <span class="{{overallStatus}}">{{overallStatusText}}</span></p>
      </div>

      <div class="section">
        <h2>ğŸ“Š æµ‹è¯•æ¦‚å†µ</h2>
        <div class="metric">
          <span>å•å…ƒæµ‹è¯•:</span>
          <span class="{{unitTestStatus}}">{{unitTestResult}}</span>
        </div>
        <div class="metric">
          <span>é›†æˆæµ‹è¯•:</span>
          <span class="{{integrationTestStatus}}">{{integrationTestResult}}</span>
        </div>
        <div class="metric">
          <span>E2Eæµ‹è¯•:</span>
          <span class="{{e2eTestStatus}}">{{e2eTestResult}}</span>
        </div>
        <div class="metric">
          <span>ä»£ç è¦†ç›–ç‡:</span>
          <span>{{coveragePercentage}}%</span>
        </div>
      </div>

      <div class="section">
        <h2>ğŸš€ æ€§èƒ½æµ‹è¯•</h2>
        <table>
          <tr>
            <th>é¡µé¢</th>
            <th>æ€§èƒ½è¯„åˆ†</th>
            <th>å¯è®¿é—®æ€§</th>
            <th>é¦–å±æ¸²æŸ“</th>
            <th>æœ€å¤§å†…å®¹æ¸²æŸ“</th>
          </tr>
          {{performanceRows}}
        </table>
      </div>

      <div class="section">
        <h2>ğŸ” è¯¦ç»†ç»“æœ</h2>
        <h3>å¤±è´¥çš„æµ‹è¯•ç”¨ä¾‹</h3>
        {{failedTests}}
      </div>
    </body>
    </html>
    `
  }

  populateTemplate(template, results) {
    const data = this.calculateSummary(results)
    
    return template
      .replace('{{timestamp}}', new Date().toLocaleString())
      .replace('{{overallStatus}}', data.overallStatus)
      .replace('{{overallStatusText}}', data.overallStatusText)
      .replace('{{unitTestStatus}}', data.unitTestStatus)
      .replace('{{unitTestResult}}', data.unitTestResult)
      .replace('{{integrationTestStatus}}', data.integrationTestStatus)
      .replace('{{integrationTestResult}}', data.integrationTestResult)
      .replace('{{e2eTestStatus}}', data.e2eTestStatus)
      .replace('{{e2eTestResult}}', data.e2eTestResult)
      .replace('{{coveragePercentage}}', data.coveragePercentage)
      .replace('{{performanceRows}}', data.performanceRows)
      .replace('{{failedTests}}', data.failedTests)
  }

  calculateSummary(results) {
    // è®¡ç®—æµ‹è¯•æ€»ç»“æ•°æ®
    const summary = {
      totalTests: 0,
      passedTests: 0,
      failedTests: 0,
      coveragePercentage: 0,
      overallStatus: 'pass',
      overallStatusText: 'é€šè¿‡'
    }

    // ç»Ÿè®¡å„ç±»æµ‹è¯•ç»“æœ
    if (results.backend.unit) {
      summary.totalTests += results.backend.unit.total
      summary.passedTests += results.backend.unit.passed
      summary.failedTests += results.backend.unit.failed
    }

    if (results.frontend.unit) {
      summary.totalTests += results.frontend.unit.numTotalTests
      summary.passedTests += results.frontend.unit.numPassedTests
      summary.failedTests += results.frontend.unit.numFailedTests
    }

    // è®¡ç®—é€šè¿‡ç‡
    const passRate = summary.totalTests > 0 ? 
      (summary.passedTests / summary.totalTests) * 100 : 0

    if (passRate < 95 || summary.failedTests > 0) {
      summary.overallStatus = 'fail'
      summary.overallStatusText = 'å¤±è´¥'
    }

    return {
      ...summary,
      unitTestStatus: summary.failedTests === 0 ? 'pass' : 'fail',
      unitTestResult: `${summary.passedTests}/${summary.totalTests}`,
      integrationTestStatus: 'pass', // ä»ç»“æœä¸­è·å–
      integrationTestResult: 'é€šè¿‡',
      e2eTestStatus: 'pass', // ä»ç»“æœä¸­è·å–
      e2eTestResult: 'é€šè¿‡',
      coveragePercentage: 85, // ä»è¦†ç›–ç‡æŠ¥å‘Šä¸­è·å–
      performanceRows: this.generatePerformanceRows(results.performance),
      failedTests: this.generateFailedTestsList(results)
    }
  }

  generatePerformanceRows(performanceResults) {
    if (!performanceResults.lighthouse) return '<tr><td colspan="5">æ— æ€§èƒ½æ•°æ®</td></tr>'

    return performanceResults.lighthouse.details.map(page => `
      <tr>
        <td>${page.page}</td>
        <td class="${page.performance > 90 ? 'pass' : 'fail'}">${page.performance}</td>
        <td class="${page.accessibility > 95 ? 'pass' : 'fail'}">${page.accessibility}</td>
        <td>${page.firstContentfulPaint}ms</td>
        <td>${page.largestContentfulPaint}ms</td>
      </tr>
    `).join('')
  }

  generateFailedTestsList(results) {
    const failedTests = []
    
    // æ”¶é›†å¤±è´¥çš„æµ‹è¯•ç”¨ä¾‹
    if (results.backend.unit && results.backend.unit.failures) {
      failedTests.push(...results.backend.unit.failures)
    }

    if (failedTests.length === 0) {
      return '<p class="pass">âœ… æ‰€æœ‰æµ‹è¯•ç”¨ä¾‹éƒ½é€šè¿‡äº†ï¼</p>'
    }

    return `
      <ul>
        ${failedTests.map(test => `
          <li class="fail">
            <strong>${test.name}</strong><br>
            <small>${test.message}</small>
          </li>
        `).join('')}
      </ul>
    `
  }

  async generateSlackReport() {
    const summary = this.calculateSummary(this.results)
    
    const slackMessage = {
      text: 'ç¾Šå’©å¿«æŠ¥æµ‹è¯•æŠ¥å‘Š',
      blocks: [
        {
          type: 'header',
          text: {
            type: 'plain_text',
            text: 'ğŸ§ª ç¾Šå’©å¿«æŠ¥æµ‹è¯•æŠ¥å‘Š'
          }
        },
        {
          type: 'section',
          fields: [
            {
              type: 'mrkdwn',
              text: `*æ€»ä½“çŠ¶æ€:* ${summary.overallStatus === 'pass' ? 'âœ… é€šè¿‡' : 'âŒ å¤±è´¥'}`
            },
            {
              type: 'mrkdwn',
              text: `*æµ‹è¯•ç”¨ä¾‹:* ${summary.passedTests}/${summary.totalTests}`
            },
            {
              type: 'mrkdwn',
              text: `*ä»£ç è¦†ç›–ç‡:* ${summary.coveragePercentage}%`
            },
            {
              type: 'mrkdwn',
              text: `*ç”Ÿæˆæ—¶é—´:* ${new Date().toLocaleString()}`
            }
          ]
        }
      ]
    }

    // ä¿å­˜Slackæ¶ˆæ¯åˆ°æ–‡ä»¶ï¼Œç”±CIæµç¨‹å‘é€
    fs.writeFileSync('slack-report.json', JSON.stringify(slackMessage, null, 2))
  }

  parseJUnitXML(filePath) {
    // è§£æJUnit XMLæ ¼å¼çš„æµ‹è¯•ç»“æœ
    const xml = fs.readFileSync(filePath, 'utf8')
    // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”è¯¥ä½¿ç”¨XMLè§£æå™¨
    return {
      total: 100,
      passed: 95,
      failed: 5,
      failures: []
    }
  }
}

// è¿è¡ŒæŠ¥å‘Šç”Ÿæˆ
if (require.main === module) {
  const generator = new TestReportGenerator()
  generator.generateReport().catch(console.error)
}

module.exports = TestReportGenerator
```

---

## 7. æµ‹è¯•æœ€ä½³å®è·µ

### 7.1 æµ‹è¯•ç¼–å†™åŸåˆ™

1. **AAAæ¨¡å¼** - Arrange, Act, Assert
2. **å•ä¸€èŒè´£** - æ¯ä¸ªæµ‹è¯•åªéªŒè¯ä¸€ä¸ªåŠŸèƒ½ç‚¹
3. **ç‹¬ç«‹æ€§** - æµ‹è¯•ä¹‹é—´ä¸åº”è¯¥æœ‰ä¾èµ–å…³ç³»
4. **å¯è¯»æ€§** - æµ‹è¯•åç§°å’Œå†…å®¹è¦æ¸…æ™°æ˜“æ‡‚
5. **å¯ç»´æŠ¤æ€§** - é¿å…é‡å¤ä»£ç ï¼Œä½¿ç”¨é€‚å½“çš„æŠ½è±¡

### 7.2 æµ‹è¯•æ•°æ®ç®¡ç†

```python
# æµ‹è¯•æ•°æ®å·¥å‚
# tests/factories.py
import factory
from apps.users.models import User
from apps.content.models import AudioContent, Artist

class UserFactory(factory.django.DjangoModelFactory):
    class Meta:
        model = User

    username = factory.Sequence(lambda n: f"user{n}")
    email = factory.LazyAttribute(lambda obj: f"{obj.username}@example.com")
    nickname = factory.Faker('name')
    is_active = True

class ArtistFactory(factory.django.DjangoModelFactory):
    class Meta:
        model = Artist

    name = factory.Faker('name')
    bio = factory.Faker('text', max_nb_chars=200)
    is_verified = True

class AudioContentFactory(factory.django.DjangoModelFactory):
    class Meta:
        model = AudioContent

    title = factory.Faker('sentence', nb_words=3)
    description = factory.Faker('text', max_nb_chars=500)
    audio_url = factory.Faker('url')
    artist = factory.SubFactory(ArtistFactory)
    duration = factory.Faker('random_int', min=60, max=600)
    is_active = True
```

### 7.3 Mockå’Œæµ‹è¯•æ›¿èº«

```javascript
// å‰ç«¯æµ‹è¯•Mock
// tests/mocks/api.js
export const mockApi = {
  content: {
    getRecommended: jest.fn().mockResolvedValue({
      success: true,
      data: {
        results: [
          {
            id: 1,
            title: 'Mock Audio 1',
            artist: { name: 'Mock Artist 1' }
          }
        ]
      }
    }),
    
    search: jest.fn().mockResolvedValue({
      success: true,
      data: {
        results: [],
        pagination: { total: 0 }
      }
    })
  },
  
  player: {
    recordPlay: jest.fn().mockResolvedValue({
      success: true
    })
  }
}

// éŸ³é¢‘Context Mock
export const mockAudioContext = {
  play: jest.fn().mockResolvedValue(),
  pause: jest.fn(),
  stop: jest.fn(),
  seek: jest.fn(),
  destroy: jest.fn(),
  onPlay: jest.fn(),
  onPause: jest.fn(),
  onTimeUpdate: jest.fn(),
  onEnded: jest.fn(),
  onError: jest.fn(),
  currentTime: 0,
  duration: 180,
  volume: 1
}
```

---

*æ­¤æ–‡æ¡£éšå¼€å‘è¿›å±•å’Œæµ‹è¯•å®è·µæŒç»­æ›´æ–°*