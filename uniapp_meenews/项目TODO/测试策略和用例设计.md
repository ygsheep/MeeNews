# 羊咩快报 - 测试策略和用例设计

## 测试策略概述

本文档制定了羊咩快报项目的全面测试策略，包括单元测试、集成测试、用户体验测试、性能测试和安全测试。确保应用的高质量交付。

---

## 1. 测试策略框架

### 1.1 测试金字塔

```
    /\
   /UI\      <- 10% (E2E测试、UI测试)
  /____\
 /      \
/Integration\ <- 20% (集成测试、API测试)
/____________\
/            \
/   Unit Tests  \ <- 70% (单元测试)
/________________\
```

#### 测试分层策略
- **单元测试 (70%)**: 测试独立的函数、组件和类
- **集成测试 (20%)**: 测试模块间的交互和API
- **UI/E2E测试 (10%)**: 测试完整的用户流程

### 1.2 测试环境

#### 环境配置
1. **开发环境 (Development)**
   - 本地开发测试
   - 快速反馈循环
   - Mock数据支持

2. **测试环境 (Testing)**
   - 自动化测试执行
   - 真实数据库
   - 第三方服务Mock

3. **预生产环境 (Staging)**
   - 生产环境镜像
   - 真实数据
   - 性能测试

4. **生产环境 (Production)**
   - 监控和报警
   - 错误追踪
   - 用户行为分析

---

## 2. 后端测试 (Django)

### 2.1 单元测试

#### 模型测试
```python
# tests/test_models.py
import pytest
from django.test import TestCase
from django.core.exceptions import ValidationError
from apps.content.models import AudioContent, Artist, Album
from apps.users.models import User

class AudioContentModelTest(TestCase):
    def setUp(self):
        self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123'
        )
        
        self.artist = Artist.objects.create(
            name='Test Artist',
            bio='Test artist bio'
        )
        
        self.album = Album.objects.create(
            title='Test Album',
            artist=self.artist
        )

    def test_audio_content_creation(self):
        """测试音频内容创建"""
        audio = AudioContent.objects.create(
            title='Test Audio',
            description='Test description',
            audio_url='https://example.com/audio.mp3',
            artist=self.artist,
            album=self.album,
            duration=180,
            file_size=5242880,
            bitrate=320,
            format='mp3'
        )
        
        self.assertEqual(audio.title, 'Test Audio')
        self.assertEqual(audio.artist, self.artist)
        self.assertEqual(audio.duration, 180)
        self.assertTrue(audio.is_active)

    def test_audio_content_validation(self):
        """测试音频内容验证"""
        with self.assertRaises(ValidationError):
            audio = AudioContent(
                title='',  # 空标题应该失败
                audio_url='invalid-url',  # 无效URL
                duration=-10  # 负数时长
            )
            audio.full_clean()

    def test_audio_content_str_representation(self):
        """测试字符串表示"""
        audio = AudioContent.objects.create(
            title='Test Audio',
            artist=self.artist,
            audio_url='https://example.com/audio.mp3',
            duration=180
        )
        
        expected = f'Test Audio - {self.artist.name}'
        self.assertEqual(str(audio), expected)

    def test_play_count_increment(self):
        """测试播放次数增加"""
        audio = AudioContent.objects.create(
            title='Test Audio',
            artist=self.artist,
            audio_url='https://example.com/audio.mp3',
            duration=180
        )
        
        initial_count = audio.play_count
        audio.increment_play_count()
        
        self.assertEqual(audio.play_count, initial_count + 1)

    def test_user_favorites(self):
        """测试用户收藏功能"""
        audio = AudioContent.objects.create(
            title='Test Audio',
            artist=self.artist,
            audio_url='https://example.com/audio.mp3',
            duration=180
        )
        
        # 添加收藏
        audio.add_to_favorites(self.user)
        self.assertTrue(audio.is_favorited_by(self.user))
        
        # 移除收藏
        audio.remove_from_favorites(self.user)
        self.assertFalse(audio.is_favorited_by(self.user))
```

#### API视图测试
```python
# tests/test_views.py
import pytest
from django.test import TestCase
from django.urls import reverse
from rest_framework.test import APIClient
from rest_framework import status
from rest_framework_simplejwt.tokens import RefreshToken
from apps.users.models import User
from apps.content.models import AudioContent, Artist

class ContentAPITest(TestCase):
    def setUp(self):
        self.client = APIClient()
        self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123'
        )
        
        # 生成JWT token
        refresh = RefreshToken.for_user(self.user)
        self.access_token = refresh.access_token
        
        self.artist = Artist.objects.create(name='Test Artist')
        
        self.audio_content = AudioContent.objects.create(
            title='Test Audio',
            artist=self.artist,
            audio_url='https://example.com/audio.mp3',
            duration=180
        )

    def authenticate(self):
        """认证用户"""
        self.client.credentials(HTTP_AUTHORIZATION=f'Bearer {self.access_token}')

    def test_get_content_list_unauthenticated(self):
        """测试未认证用户获取内容列表"""
        url = reverse('content-list')
        response = self.client.get(url)
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertIn('results', response.data['data'])

    def test_get_content_detail_authenticated(self):
        """测试认证用户获取内容详情"""
        self.authenticate()
        url = reverse('content-detail', kwargs={'pk': self.audio_content.id})
        response = self.client.get(url)
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['data']['id'], self.audio_content.id)
        self.assertEqual(response.data['data']['title'], 'Test Audio')

    def test_favorite_content(self):
        """测试收藏内容"""
        self.authenticate()
        url = reverse('user-favorites')
        data = {
            'content_id': self.audio_content.id,
            'content_type': 'audio'
        }
        
        response = self.client.post(url, data)
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        
        # 验证收藏成功
        self.assertTrue(
            self.audio_content.is_favorited_by(self.user)
        )

    def test_search_content(self):
        """测试内容搜索"""
        url = reverse('content-search')
        response = self.client.get(url, {'q': 'Test'})
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertGreaterEqual(len(response.data['data']['results']), 1)

    def test_play_history_recording(self):
        """测试播放历史记录"""
        self.authenticate()
        url = reverse('player-play')
        data = {
            'content_id': self.audio_content.id,
            'play_duration': 120,
            'completion_rate': 66.67,
            'device_type': 'mobile'
        }
        
        response = self.client.post(url, data)
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)

    def test_recommendation_api(self):
        """测试推荐API"""
        self.authenticate()
        url = reverse('content-recommend')
        response = self.client.get(url)
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertIn('results', response.data['data'])

    def test_invalid_content_id(self):
        """测试无效内容ID"""
        self.authenticate()
        url = reverse('content-detail', kwargs={'pk': 99999})
        response = self.client.get(url)
        
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)

    def test_rate_limiting(self):
        """测试频率限制"""
        url = reverse('content-search')
        
        # 模拟大量请求
        for i in range(101):  # 假设限制是100次/分钟
            response = self.client.get(url, {'q': f'test{i}'})
            
        # 最后一次请求应该被限制
        self.assertEqual(response.status_code, status.HTTP_429_TOO_MANY_REQUESTS)
```

#### 服务层测试
```python
# tests/test_services.py
import pytest
from unittest.mock import Mock, patch
from apps.ai.services import RecommendationEngine
from apps.content.services import AudioProcessingService
from apps.users.models import User

class RecommendationEngineTest(TestCase):
    def setUp(self):
        self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123'
        )
        self.engine = RecommendationEngine()

    @patch('apps.ai.services.RecommendationEngine.get_user_behavior')
    def test_generate_recommendations(self, mock_get_behavior):
        """测试推荐生成"""
        # Mock用户行为数据
        mock_get_behavior.return_value = {
            'play_history': [],
            'favorites': [],
            'ratings': [],
            'search_history': []
        }
        
        recommendations = self.engine.generate_recommendations(self.user.id, limit=10)
        
        self.assertIsInstance(recommendations, list)
        self.assertLessEqual(len(recommendations), 10)

    def test_user_preference_analysis(self):
        """测试用户偏好分析"""
        behavior = {
            'play_history': [],
            'favorites': [],
            'ratings': []
        }
        
        preferences = self.engine.analyze_user_preferences(behavior)
        
        self.assertIn('favorite_categories', preferences)
        self.assertIn('favorite_artists', preferences)
        self.assertIn('listening_time_patterns', preferences)

    def test_content_similarity_calculation(self):
        """测试内容相似度计算"""
        content1_features = {
            'genre': 'pop',
            'tempo': 120,
            'energy': 0.8,
            'danceability': 0.7
        }
        
        content2_features = {
            'genre': 'pop',
            'tempo': 125,
            'energy': 0.85,
            'danceability': 0.75
        }
        
        similarity = self.engine.calculate_content_similarity(
            content1_features, 
            content2_features
        )
        
        self.assertGreaterEqual(similarity, 0.0)
        self.assertLessEqual(similarity, 1.0)
        self.assertGreater(similarity, 0.8)  # 应该很相似

class AudioProcessingServiceTest(TestCase):
    def setUp(self):
        self.service = AudioProcessingService()

    @patch('apps.content.services.AudioProcessingService.extract_audio_features')
    def test_audio_analysis(self, mock_extract):
        """测试音频分析"""
        mock_extract.return_value = {
            'duration': 180,
            'bitrate': 320,
            'sample_rate': 44100,
            'channels': 2,
            'tempo': 120,
            'key': 'C',
            'energy': 0.8
        }
        
        audio_url = 'https://example.com/test.mp3'
        features = self.service.analyze_audio(audio_url)
        
        self.assertEqual(features['duration'], 180)
        self.assertEqual(features['bitrate'], 320)
        mock_extract.assert_called_once_with(audio_url)

    def test_audio_format_validation(self):
        """测试音频格式验证"""
        valid_formats = ['mp3', 'm4a', 'wav', 'flac']
        invalid_formats = ['mp4', 'avi', 'txt', 'jpg']
        
        for format_type in valid_formats:
            self.assertTrue(self.service.is_valid_audio_format(format_type))
            
        for format_type in invalid_formats:
            self.assertFalse(self.service.is_valid_audio_format(format_type))

    def test_audio_quality_assessment(self):
        """测试音频质量评估"""
        low_quality = {'bitrate': 128, 'sample_rate': 22050}
        medium_quality = {'bitrate': 192, 'sample_rate': 44100}
        high_quality = {'bitrate': 320, 'sample_rate': 44100}
        
        self.assertEqual(self.service.assess_audio_quality(low_quality), 'low')
        self.assertEqual(self.service.assess_audio_quality(medium_quality), 'medium')
        self.assertEqual(self.service.assess_audio_quality(high_quality), 'high')
```

### 2.2 集成测试

#### 数据库集成测试
```python
# tests/integration/test_database.py
import pytest
from django.test import TransactionTestCase
from django.db import transaction
from apps.users.models import User
from apps.content.models import AudioContent, Artist
from apps.player.models import PlayHistory

class DatabaseIntegrationTest(TransactionTestCase):
    def test_complex_query_performance(self):
        """测试复杂查询性能"""
        # 创建测试数据
        users = []
        for i in range(100):
            user = User.objects.create_user(
                username=f'user{i}',
                email=f'user{i}@example.com',
                password='testpass123'
            )
            users.append(user)
        
        artist = Artist.objects.create(name='Test Artist')
        
        contents = []
        for i in range(1000):
            content = AudioContent.objects.create(
                title=f'Test Audio {i}',
                artist=artist,
                audio_url=f'https://example.com/audio{i}.mp3',
                duration=180 + i,
                play_count=i * 10
            )
            contents.append(content)
        
        # 测试复杂查询
        import time
        start_time = time.time()
        
        # 获取热门内容
        popular_contents = AudioContent.objects.filter(
            is_active=True,
            play_count__gte=100
        ).select_related('artist').order_by('-play_count')[:20]
        
        query_time = time.time() - start_time
        
        self.assertLess(query_time, 1.0)  # 查询应在1秒内完成
        self.assertGreater(len(popular_contents), 0)

    def test_transaction_integrity(self):
        """测试事务完整性"""
        user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123'
        )
        
        artist = Artist.objects.create(name='Test Artist')
        
        content = AudioContent.objects.create(
            title='Test Audio',
            artist=artist,
            audio_url='https://example.com/audio.mp3',
            duration=180
        )
        
        try:
            with transaction.atomic():
                # 记录播放历史
                PlayHistory.objects.create(
                    user=user,
                    content=content,
                    play_duration=120,
                    completion_rate=66.67
                )
                
                # 增加播放次数
                content.play_count += 1
                content.save()
                
                # 模拟错误
                raise Exception("Simulated error")
                
        except Exception:
            pass
        
        # 验证事务回滚
        content.refresh_from_db()
        self.assertEqual(content.play_count, 0)
        self.assertEqual(PlayHistory.objects.count(), 0)

    def test_concurrent_access(self):
        """测试并发访问"""
        import threading
        import time
        
        user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123'
        )
        
        artist = Artist.objects.create(name='Test Artist')
        
        content = AudioContent.objects.create(
            title='Test Audio',
            artist=artist,
            audio_url='https://example.com/audio.mp3',
            duration=180
        )
        
        def increment_play_count():
            for _ in range(10):
                content.increment_play_count()
                time.sleep(0.01)
        
        # 创建多个线程同时增加播放次数
        threads = []
        for _ in range(5):
            thread = threading.Thread(target=increment_play_count)
            threads.append(thread)
            thread.start()
        
        # 等待所有线程完成
        for thread in threads:
            thread.join()
        
        content.refresh_from_db()
        self.assertEqual(content.play_count, 50)
```

#### API集成测试
```python
# tests/integration/test_api_integration.py
import pytest
from django.test import TestCase
from rest_framework.test import APIClient
from rest_framework import status
from unittest.mock import patch
from apps.users.models import User

class APIIntegrationTest(TestCase):
    def setUp(self):
        self.client = APIClient()
        self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123'
        )

    def test_complete_user_journey(self):
        """测试完整的用户使用流程"""
        # 1. 用户注册
        register_data = {
            'username': 'newuser',
            'email': 'newuser@example.com',
            'password': 'newpass123',
            'password_confirm': 'newpass123'
        }
        
        response = self.client.post('/api/v1/auth/register', register_data)
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        
        token = response.data['data']['token']['access']
        
        # 2. 获取推荐内容
        self.client.credentials(HTTP_AUTHORIZATION=f'Bearer {token}')
        response = self.client.get('/api/v1/content/recommend')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        
        recommended_content = response.data['data']['results'][0]
        content_id = recommended_content['id']
        
        # 3. 播放音频
        play_data = {
            'content_id': content_id,
            'device_type': 'mobile'
        }
        
        response = self.client.post('/api/v1/player/play', play_data)
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        
        # 4. 收藏音频
        favorite_data = {
            'content_id': content_id,
            'content_type': 'audio'
        }
        
        response = self.client.post('/api/v1/user/favorites', favorite_data)
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        
        # 5. 获取收藏列表
        response = self.client.get('/api/v1/user/favorites')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertGreater(len(response.data['data']['results']), 0)

    @patch('apps.ai.services.tts_service.synthesize')
    def test_ai_tts_integration(self, mock_tts):
        """测试AI TTS集成"""
        mock_tts.return_value = {
            'task_id': 'tts_12345',
            'status': 'completed',
            'audio_url': 'https://example.com/tts_audio.mp3'
        }
        
        # 登录
        login_data = {
            'login': 'testuser',
            'password': 'testpass123'
        }
        
        response = self.client.post('/api/v1/auth/login', login_data)
        token = response.data['data']['token']['access']
        
        # TTS请求
        self.client.credentials(HTTP_AUTHORIZATION=f'Bearer {token}')
        tts_data = {
            'text': '欢迎使用羊咩快报',
            'voice_type': 'standard_female',
            'speed': 1.0
        }
        
        response = self.client.post('/api/v1/ai/tts', tts_data)
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        
        task_id = response.data['data']['task_id']
        
        # 检查TTS状态
        response = self.client.get(f'/api/v1/ai/tts/{task_id}')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['data']['status'], 'completed')

    def test_search_integration(self):
        """测试搜索功能集成"""
        # 搜索建议
        response = self.client.get('/api/v1/ai/search/suggest', {'q': 'test'})
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        
        # 执行搜索
        response = self.client.get('/api/v1/content/search', {'q': 'test music'})
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        
        # 验证搜索结果结构
        self.assertIn('results', response.data['data'])
        self.assertIn('pagination', response.data['data'])

    def test_error_handling_integration(self):
        """测试错误处理集成"""
        # 测试无效token
        self.client.credentials(HTTP_AUTHORIZATION='Bearer invalid_token')
        response = self.client.get('/api/v1/user/profile')
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
        
        # 测试资源不存在
        response = self.client.get('/api/v1/content/99999')
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)
        
        # 测试请求参数错误
        response = self.client.post('/api/v1/auth/register', {})
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
```

---

## 3. 前端测试 (UniApp)

### 3.1 组件单元测试

#### Vue组件测试
```javascript
// tests/unit/components/ContentCard.spec.js
import { mount } from '@vue/test-utils'
import { createPinia } from 'pinia'
import ContentCard from '@/components/content/ContentCard.vue'

describe('ContentCard.vue', () => {
  let wrapper
  let pinia

  const mockContent = {
    id: 1,
    title: 'Test Audio',
    artist: {
      id: 1,
      name: 'Test Artist'
    },
    cover_url: 'https://example.com/cover.jpg',
    duration: 180,
    play_count: 1000,
    is_liked: false
  }

  beforeEach(() => {
    pinia = createPinia()
    wrapper = mount(ContentCard, {
      global: {
        plugins: [pinia]
      },
      props: {
        content: mockContent,
        cardType: 'small'
      }
    })
  })

  afterEach(() => {
    wrapper.unmount()
  })

  it('renders content information correctly', () => {
    expect(wrapper.find('.card-title').text()).toBe('Test Audio')
    expect(wrapper.find('.card-artist').text()).toBe('Test Artist')
    expect(wrapper.find('.card-cover').attributes('src')).toBe('https://example.com/cover.jpg')
  })

  it('formats duration correctly', () => {
    const durationText = wrapper.find('.duration-label').text()
    expect(durationText).toBe('3:00')
  })

  it('emits click event when card is clicked', async () => {
    await wrapper.trigger('click')
    expect(wrapper.emitted('click')).toBeTruthy()
    expect(wrapper.emitted('click')[0][0]).toEqual(mockContent)
  })

  it('toggles like status when like button is clicked', async () => {
    const likeButton = wrapper.find('.like-button')
    await likeButton.trigger('click')
    
    expect(wrapper.emitted('like')).toBeTruthy()
    expect(wrapper.emitted('like')[0][0]).toEqual(mockContent)
  })

  it('applies correct card type class', () => {
    expect(wrapper.classes()).toContain('card-small')
  })

  it('shows play indicator when content is currently playing', async () => {
    // Mock store state
    const playerStore = usePlayerStore()
    playerStore.currentTrack = { id: 1 }
    playerStore.isPlaying = true

    await wrapper.vm.$nextTick()
    expect(wrapper.find('.play-indicator').exists()).toBe(true)
  })

  it('formats play count correctly', () => {
    const playCountText = wrapper.find('.play-count').text()
    expect(playCountText).toBe('1K 次播放')
  })
})
```

#### Store测试
```javascript
// tests/unit/store/player.spec.js
import { setActivePinia, createPinia } from 'pinia'
import { usePlayerStore } from '@/store/modules/player'

describe('Player Store', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
  })

  it('initializes with default state', () => {
    const store = usePlayerStore()
    
    expect(store.currentTrack).toBe(null)
    expect(store.isPlaying).toBe(false)
    expect(store.currentTime).toBe(0)
    expect(store.duration).toBe(0)
    expect(store.volume).toBe(1.0)
    expect(store.shuffleMode).toBe(false)
    expect(store.repeatMode).toBe('none')
  })

  it('calculates progress percent correctly', () => {
    const store = usePlayerStore()
    store.currentTime = 90
    store.duration = 180
    
    expect(store.progressPercent).toBe(50)
  })

  it('handles play track action', async () => {
    const store = usePlayerStore()
    const mockTrack = {
      id: 1,
      title: 'Test Track',
      audio_url: 'https://example.com/audio.mp3',
      duration: 180
    }

    // Mock audio context
    global.uni = {
      createInnerAudioContext: jest.fn().mockReturnValue({
        play: jest.fn().mockResolvedValue(),
        onPlay: jest.fn(),
        onPause: jest.fn(),
        onTimeUpdate: jest.fn(),
        onEnded: jest.fn(),
        onError: jest.fn()
      })
    }

    await store.playTrack(mockTrack)
    
    expect(store.currentTrack).toEqual(mockTrack)
    expect(store.isLoading).toBe(false)
  })

  it('toggles play/pause correctly', async () => {
    const store = usePlayerStore()
    const mockAudioContext = {
      play: jest.fn().mockResolvedValue(),
      pause: jest.fn()
    }

    store.audioContext = mockAudioContext
    store.isPlaying = false

    await store.togglePlay()
    expect(mockAudioContext.play).toHaveBeenCalled()

    store.isPlaying = true
    await store.togglePlay()
    expect(mockAudioContext.pause).toHaveBeenCalled()
  })

  it('handles next track correctly in sequence mode', () => {
    const store = usePlayerStore()
    store.playQueue = [
      { id: 1, title: 'Track 1' },
      { id: 2, title: 'Track 2' },
      { id: 3, title: 'Track 3' }
    ]
    store.currentIndex = 0
    store.shuffleMode = false

    const nextIndex = store.getNextTrackIndex()
    expect(nextIndex).toBe(1)
  })

  it('handles next track correctly in shuffle mode', () => {
    const store = usePlayerStore()
    store.playQueue = [
      { id: 1, title: 'Track 1' },
      { id: 2, title: 'Track 2' },
      { id: 3, title: 'Track 3' }
    ]
    store.currentIndex = 0
    store.shuffleMode = true

    const nextIndex = store.getNextTrackIndex()
    expect(nextIndex).toBeGreaterThanOrEqual(0)
    expect(nextIndex).toBeLessThan(store.playQueue.length)
    expect(nextIndex).not.toBe(0) // 不应该是当前索引
  })

  it('handles repeat modes correctly', () => {
    const store = usePlayerStore()
    
    // 测试重复模式切换
    expect(store.repeatMode).toBe('none')
    
    store.toggleRepeat()
    expect(store.repeatMode).toBe('one')
    
    store.toggleRepeat()
    expect(store.repeatMode).toBe('all')
    
    store.toggleRepeat()
    expect(store.repeatMode).toBe('none')
  })

  it('records play history correctly', () => {
    const store = usePlayerStore()
    const mockTrack = {
      id: 1,
      title: 'Test Track'
    }

    store.addToHistory(mockTrack)
    
    expect(store.playHistory).toHaveLength(1)
    expect(store.playHistory[0].id).toBe(1)
    expect(store.playHistory[0].playedAt).toBeDefined()
  })

  it('limits play history size', () => {
    const store = usePlayerStore()
    
    // 添加超过限制的历史记录
    for (let i = 0; i < 1005; i++) {
      store.addToHistory({
        id: i,
        title: `Track ${i}`
      })
    }
    
    expect(store.playHistory).toHaveLength(1000)
  })
})
```

### 3.2 集成测试

#### 页面集成测试
```javascript
// tests/integration/pages/Index.spec.js
import { mount } from '@vue/test-utils'
import { createPinia } from 'pinia'
import IndexPage from '@/pages/index/index.vue'
import * as api from '@/api'

// Mock API calls
jest.mock('@/api', () => ({
  content: {
    getRecommended: jest.fn(),
    getByCategory: jest.fn()
  },
  user: {
    getProfile: jest.fn()
  }
}))

describe('Index Page Integration', () => {
  let wrapper
  let pinia

  beforeEach(() => {
    pinia = createPinia()
    
    // Mock API responses
    api.content.getRecommended.mockResolvedValue({
      success: true,
      data: {
        results: [
          {
            id: 1,
            title: 'Test Audio 1',
            artist: { name: 'Artist 1' },
            cover_url: 'https://example.com/cover1.jpg'
          },
          {
            id: 2,
            title: 'Test Audio 2',
            artist: { name: 'Artist 2' },
            cover_url: 'https://example.com/cover2.jpg'
          }
        ]
      }
    })

    api.user.getProfile.mockResolvedValue({
      success: true,
      data: {
        nickname: 'Test User'
      }
    })

    wrapper = mount(IndexPage, {
      global: {
        plugins: [pinia],
        mocks: {
          $router: {
            push: jest.fn()
          }
        }
      }
    })
  })

  afterEach(() => {
    wrapper.unmount()
    jest.clearAllMocks()
  })

  it('loads and displays recommended content', async () => {
    await wrapper.vm.$nextTick()
    await new Promise(resolve => setTimeout(resolve, 0))

    expect(api.content.getRecommended).toHaveBeenCalled()
    
    const contentCards = wrapper.findAllComponents({ name: 'ContentCard' })
    expect(contentCards).toHaveLength(2)
  })

  it('displays greeting with user name', async () => {
    const userStore = useUserStore()
    userStore.userInfo = { nickname: 'Test User' }

    await wrapper.vm.$nextTick()

    const greeting = wrapper.find('.greeting-text')
    expect(greeting.text()).toContain('Test User')
  })

  it('handles category selection', async () => {
    const categoryItems = wrapper.findAll('.category-item')
    
    await categoryItems[1].trigger('click')
    
    expect(api.content.getByCategory).toHaveBeenCalledWith(
      expect.objectContaining({
        category_id: expect.any(Number)
      })
    )
  })

  it('navigates to search page when search icon is clicked', async () => {
    const searchIcon = wrapper.find('[name="search"]')
    await searchIcon.trigger('click')

    expect(wrapper.vm.$router.push).toHaveBeenCalledWith('/pages/discover/search')
  })

  it('plays content when content card is clicked', async () => {
    await wrapper.vm.$nextTick()
    
    const playerStore = usePlayerStore()
    const playTrackSpy = jest.spyOn(playerStore, 'playTrack')

    const contentCard = wrapper.findComponent({ name: 'ContentCard' })
    await contentCard.trigger('click')

    expect(playTrackSpy).toHaveBeenCalled()
  })

  it('handles loading states correctly', async () => {
    // Initial loading state
    expect(wrapper.find('.loading').exists()).toBe(true)

    await wrapper.vm.$nextTick()
    await new Promise(resolve => setTimeout(resolve, 0))

    // Loading should be hidden after data loads
    expect(wrapper.find('.loading').exists()).toBe(false)
  })

  it('handles error states correctly', async () => {
    // Mock API error
    api.content.getRecommended.mockRejectedValue(new Error('Network error'))

    const newWrapper = mount(IndexPage, {
      global: {
        plugins: [pinia]
      }
    })

    await newWrapper.vm.$nextTick()
    await new Promise(resolve => setTimeout(resolve, 0))

    expect(newWrapper.find('.error-message').exists()).toBe(true)
    
    newWrapper.unmount()
  })
})
```

#### 播放器集成测试
```javascript
// tests/integration/player/PlayerIntegration.spec.js
import { mount } from '@vue/test-utils'
import { createPinia } from 'pinia'
import PlayerPage from '@/pages/player/player.vue'
import MiniPlayer from '@/components/player/MiniPlayer.vue'

describe('Player Integration', () => {
  let wrapper
  let pinia
  let playerStore

  const mockTrack = {
    id: 1,
    title: 'Test Track',
    artist: { name: 'Test Artist' },
    cover_url: 'https://example.com/cover.jpg',
    audio_url: 'https://example.com/audio.mp3',
    duration: 180
  }

  beforeEach(() => {
    pinia = createPinia()
    playerStore = usePlayerStore()
    
    // Mock audio context
    global.uni = {
      createInnerAudioContext: jest.fn().mockReturnValue({
        play: jest.fn().mockResolvedValue(),
        pause: jest.fn(),
        stop: jest.fn(),
        seek: jest.fn(),
        destroy: jest.fn(),
        onPlay: jest.fn(),
        onPause: jest.fn(),
        onTimeUpdate: jest.fn(),
        onEnded: jest.fn(),
        onError: jest.fn(),
        currentTime: 0,
        duration: 180,
        volume: 1
      })
    }

    playerStore.currentTrack = mockTrack
    playerStore.isPlaying = false

    wrapper = mount(PlayerPage, {
      global: {
        plugins: [pinia]
      }
    })
  })

  afterEach(() => {
    wrapper.unmount()
  })

  it('displays current track information', () => {
    expect(wrapper.find('.track-title').text()).toBe('Test Track')
    expect(wrapper.find('.track-artist').text()).toBe('Test Artist')
    expect(wrapper.find('.cover-image').attributes('src')).toBe('https://example.com/cover.jpg')
  })

  it('toggles play/pause when play button is clicked', async () => {
    const playButton = wrapper.find('.play-button')
    const togglePlaySpy = jest.spyOn(playerStore, 'togglePlay')

    await playButton.trigger('click')
    expect(togglePlaySpy).toHaveBeenCalled()
  })

  it('seeks to correct position when progress bar is clicked', async () => {
    const progressBar = wrapper.find('.progress-section')
    const seekSpy = jest.spyOn(playerStore, 'seek')

    // Mock getBoundingClientRect
    progressBar.element.getBoundingClientRect = jest.fn().mockReturnValue({
      left: 0,
      width: 100
    })

    await progressBar.trigger('click', { clientX: 50 })
    expect(seekSpy).toHaveBeenCalledWith(90) // 50% of 180 seconds
  })

  it('plays next track when next button is clicked', async () => {
    const nextButton = wrapper.find('[name="skip-next"]')
    const playNextSpy = jest.spyOn(playerStore, 'playNext')

    await nextButton.trigger('click')
    expect(playNextSpy).toHaveBeenCalled()
  })

  it('plays previous track when previous button is clicked', async () => {
    const prevButton = wrapper.find('[name="skip-previous"]')
    const playPreviousSpy = jest.spyOn(playerStore, 'playPrevious')

    await prevButton.trigger('click')
    expect(playPreviousSpy).toHaveBeenCalled()
  })

  it('updates UI when playback state changes', async () => {
    // Initially not playing
    expect(wrapper.find('[name="play"]').exists()).toBe(true)
    expect(wrapper.find('[name="pause"]').exists()).toBe(false)

    // Change to playing state
    playerStore.isPlaying = true
    await wrapper.vm.$nextTick()

    expect(wrapper.find('[name="play"]').exists()).toBe(false)
    expect(wrapper.find('[name="pause"]').exists()).toBe(true)
  })

  it('updates progress display during playback', async () => {
    playerStore.currentTime = 90
    playerStore.duration = 180
    await wrapper.vm.$nextTick()

    expect(wrapper.find('.time-text').at(0).text()).toBe('1:30')
    expect(wrapper.find('.time-text').at(1).text()).toBe('3:00')
  })

  it('integrates with mini player correctly', async () => {
    const miniPlayer = mount(MiniPlayer, {
      global: {
        plugins: [pinia]
      }
    })

    expect(miniPlayer.find('.track-title').text()).toBe('Test Track')
    expect(miniPlayer.find('.track-artist').text()).toBe('Test Artist')

    // Click mini player to navigate to full player
    const navigateSpy = jest.spyOn(uni, 'navigateTo')
    await miniPlayer.trigger('click')

    expect(navigateSpy).toHaveBeenCalledWith({
      url: '/pages/player/player'
    })

    miniPlayer.unmount()
  })
})
```

---

## 4. 性能测试

### 4.1 负载测试

#### API负载测试脚本
```javascript
// tests/performance/load-test.js
import http from 'k6/http'
import { check, sleep } from 'k6'
import { Rate } from 'k6/metrics'

export let errorRate = new Rate('errors')

export let options = {
  stages: [
    { duration: '2m', target: 100 }, // 2分钟内增加到100用户
    { duration: '5m', target: 100 }, // 保持100用户5分钟
    { duration: '2m', target: 200 }, // 2分钟内增加到200用户
    { duration: '5m', target: 200 }, // 保持200用户5分钟
    { duration: '2m', target: 0 },   // 2分钟内减少到0用户
  ],
  thresholds: {
    http_req_duration: ['p(99)<1500'], // 99%的请求在1.5秒内完成
    http_req_failed: ['rate<0.1'],     // 错误率低于10%
    errors: ['rate<0.1'],
  },
}

const BASE_URL = 'https://api.yangmie.com/v1'

// 模拟用户登录获取token
function getAuthToken() {
  const loginData = {
    login: 'testuser',
    password: 'testpass123'
  }

  const response = http.post(`${BASE_URL}/auth/login`, JSON.stringify(loginData), {
    headers: { 'Content-Type': 'application/json' }
  })

  const success = check(response, {
    'login successful': (r) => r.status === 200,
    'login response has token': (r) => r.json('data.token.access') !== undefined
  })

  if (success) {
    return response.json('data.token.access')
  }
  return null
}

export default function () {
  // 1. 测试首页推荐内容API
  let response = http.get(`${BASE_URL}/content/recommend`)
  
  let success = check(response, {
    'recommend status is 200': (r) => r.status === 200,
    'recommend has results': (r) => r.json('data.results.length') > 0,
    'recommend response time < 500ms': (r) => r.timings.duration < 500
  })
  
  errorRate.add(!success)

  // 2. 测试搜索API
  response = http.get(`${BASE_URL}/content/search?q=test&page=1&page_size=20`)
  
  success = check(response, {
    'search status is 200': (r) => r.status === 200,
    'search has pagination': (r) => r.json('data.pagination') !== undefined,
    'search response time < 800ms': (r) => r.timings.duration < 800
  })
  
  errorRate.add(!success)

  // 3. 获取认证token并测试需要认证的API
  const token = getAuthToken()
  
  if (token) {
    const headers = {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    }

    // 测试用户资料API
    response = http.get(`${BASE_URL}/users/profile`, { headers })
    
    success = check(response, {
      'profile status is 200': (r) => r.status === 200,
      'profile has user data': (r) => r.json('data.id') !== undefined
    })
    
    errorRate.add(!success)

    // 测试播放记录API
    const playData = {
      content_id: 1,
      play_duration: 120,
      completion_rate: 66.67,
      device_type: 'mobile'
    }

    response = http.post(`${BASE_URL}/player/play`, JSON.stringify(playData), { headers })
    
    success = check(response, {
      'play record status is 201': (r) => r.status === 201
    })
    
    errorRate.add(!success)
  }

  sleep(1) // 用户操作间隔
}

// 性能测试报告
export function handleSummary(data) {
  return {
    'performance-report.html': htmlReport(data),
    'performance-summary.json': JSON.stringify(data, null, 2)
  }
}

function htmlReport(data) {
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <title>羊咩快报 - 性能测试报告</title>
      <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .metric { background: #f5f5f5; padding: 10px; margin: 10px 0; border-radius: 5px; }
        .pass { color: green; }
        .fail { color: red; }
      </style>
    </head>
    <body>
      <h1>羊咩快报 - 性能测试报告</h1>
      
      <h2>测试概况</h2>
      <div class="metric">
        <strong>测试时长:</strong> ${data.state.testRunDurationMs / 1000}秒<br>
        <strong>虚拟用户数:</strong> ${data.metrics.vus.values.max}<br>
        <strong>请求总数:</strong> ${data.metrics.http_reqs.values.count}<br>
        <strong>错误率:</strong> ${(data.metrics.http_req_failed.values.rate * 100).toFixed(2)}%
      </div>

      <h2>响应时间</h2>
      <div class="metric">
        <strong>平均响应时间:</strong> ${data.metrics.http_req_duration.values.avg.toFixed(2)}ms<br>
        <strong>95%分位:</strong> ${data.metrics.http_req_duration.values['p(95)'].toFixed(2)}ms<br>
        <strong>99%分位:</strong> ${data.metrics.http_req_duration.values['p(99)'].toFixed(2)}ms
      </div>

      <h2>阈值检查</h2>
      ${Object.entries(data.thresholds).map(([name, threshold]) => `
        <div class="metric ${threshold.ok ? 'pass' : 'fail'}">
          <strong>${name}:</strong> ${threshold.ok ? '通过' : '失败'}
        </div>
      `).join('')}
    </body>
    </html>
  `
}
```

### 4.2 前端性能测试

#### Lighthouse自动化测试
```javascript
// tests/performance/lighthouse-test.js
const lighthouse = require('lighthouse')
const chromeLauncher = require('chrome-launcher')
const fs = require('fs')

async function runLighthouseTest() {
  const chrome = await chromeLauncher.launch({ chromeFlags: ['--headless'] })
  
  const options = {
    logLevel: 'info',
    output: 'html',
    onlyCategories: ['performance', 'accessibility', 'best-practices', 'seo'],
    port: chrome.port
  }

  // 测试不同页面
  const pages = [
    { name: 'Home', url: 'https://yangmie.com' },
    { name: 'Search', url: 'https://yangmie.com/search' },
    { name: 'Player', url: 'https://yangmie.com/player' }
  ]

  const results = []

  for (const page of pages) {
    console.log(`Testing ${page.name} page...`)
    
    const runnerResult = await lighthouse(page.url, options)
    const reportHtml = runnerResult.report
    
    // 保存详细报告
    fs.writeFileSync(`lighthouse-${page.name.toLowerCase()}.html`, reportHtml)
    
    // 提取关键指标
    const { lhr } = runnerResult
    const metrics = {
      page: page.name,
      performance: lhr.categories.performance.score * 100,
      accessibility: lhr.categories.accessibility.score * 100,
      bestPractices: lhr.categories['best-practices'].score * 100,
      seo: lhr.categories.seo.score * 100,
      firstContentfulPaint: lhr.audits['first-contentful-paint'].numericValue,
      largestContentfulPaint: lhr.audits['largest-contentful-paint'].numericValue,
      cumulativeLayoutShift: lhr.audits['cumulative-layout-shift'].numericValue,
      totalBlockingTime: lhr.audits['total-blocking-time'].numericValue
    }
    
    results.push(metrics)
    
    // 性能阈值检查
    const performanceThresholds = {
      performance: 90,
      accessibility: 95,
      firstContentfulPaint: 1500,
      largestContentfulPaint: 2500,
      cumulativeLayoutShift: 0.1
    }
    
    console.log(`${page.name} Performance Score: ${metrics.performance}`)
    console.log(`${page.name} Accessibility Score: ${metrics.accessibility}`)
    
    if (metrics.performance < performanceThresholds.performance) {
      console.warn(`⚠️  ${page.name} performance score below threshold!`)
    }
    
    if (metrics.firstContentfulPaint > performanceThresholds.firstContentfulPaint) {
      console.warn(`⚠️  ${page.name} FCP too slow!`)
    }
  }

  await chrome.kill()
  
  // 生成性能报告
  generatePerformanceReport(results)
  
  return results
}

function generatePerformanceReport(results) {
  const report = {
    timestamp: new Date().toISOString(),
    summary: {
      averagePerformance: results.reduce((sum, r) => sum + r.performance, 0) / results.length,
      averageAccessibility: results.reduce((sum, r) => sum + r.accessibility, 0) / results.length,
      averageFCP: results.reduce((sum, r) => sum + r.firstContentfulPaint, 0) / results.length,
      averageLCP: results.reduce((sum, r) => sum + r.largestContentfulPaint, 0) / results.length
    },
    details: results
  }

  fs.writeFileSync('performance-report.json', JSON.stringify(report, null, 2))
  
  console.log('\n📊 Performance Report Generated:')
  console.log(`Average Performance Score: ${report.summary.averagePerformance.toFixed(1)}`)
  console.log(`Average Accessibility Score: ${report.summary.averageAccessibility.toFixed(1)}`)
  console.log(`Average FCP: ${report.summary.averageFCP.toFixed(0)}ms`)
  console.log(`Average LCP: ${report.summary.averageLCP.toFixed(0)}ms`)
}

// 运行测试
if (require.main === module) {
  runLighthouseTest().catch(console.error)
}

module.exports = { runLighthouseTest }
```

---

## 5. 端到端测试 (E2E)

### 5.1 用户流程测试

#### Cypress E2E测试
```javascript
// cypress/integration/user-journey.spec.js
describe('羊咩快报 - 完整用户流程', () => {
  beforeEach(() => {
    // 清理cookies和localStorage
    cy.clearCookies()
    cy.clearLocalStorage()
    
    // 访问首页
    cy.visit('/')
  })

  it('新用户注册到播放音乐的完整流程', () => {
    // 1. 点击注册
    cy.contains('注册').click()
    
    // 2. 填写注册信息
    cy.get('[data-cy="username"]').type('newuser123')
    cy.get('[data-cy="email"]').type('newuser@example.com')
    cy.get('[data-cy="password"]').type('password123')
    cy.get('[data-cy="password-confirm"]').type('password123')
    
    // 3. 提交注册
    cy.get('[data-cy="register-submit"]').click()
    
    // 4. 验证注册成功，跳转到首页
    cy.url().should('include', '/pages/index/index')
    cy.contains('Good Morning').should('be.visible')
    
    // 5. 浏览推荐内容
    cy.get('[data-cy="content-card"]').should('have.length.greaterThan', 0)
    
    // 6. 点击播放第一首音乐
    cy.get('[data-cy="content-card"]').first().click()
    
    // 7. 验证播放器启动
    cy.get('[data-cy="mini-player"]').should('be.visible')
    cy.get('[data-cy="play-button"]').should('contain', 'pause')
    
    // 8. 打开全屏播放器
    cy.get('[data-cy="mini-player"]').click()
    cy.url().should('include', '/pages/player/player')
    
    // 9. 测试播放控制
    cy.get('[data-cy="pause-button"]').click()
    cy.get('[data-cy="play-button"]').should('be.visible')
    
    // 10. 收藏当前歌曲
    cy.get('[data-cy="favorite-button"]').click()
    cy.get('[data-cy="favorite-button"]').should('have.class', 'favorited')
    
    // 11. 返回首页
    cy.get('[data-cy="back-button"]').click()
    
    // 12. 查看收藏列表
    cy.get('[data-cy="tab-library"]').click()
    cy.get('[data-cy="favorites-section"]').click()
    cy.get('[data-cy="favorite-item"]').should('have.length', 1)
  })

  it('搜索和播放音乐流程', () => {
    // 1. 点击搜索
    cy.get('[data-cy="search-button"]').click()
    
    // 2. 输入搜索关键词
    cy.get('[data-cy="search-input"]').type('test music')
    
    // 3. 查看搜索建议
    cy.get('[data-cy="search-suggestion"]').should('be.visible')
    cy.get('[data-cy="search-suggestion"]').first().click()
    
    // 4. 查看搜索结果
    cy.get('[data-cy="search-result"]').should('have.length.greaterThan', 0)
    
    // 5. 筛选结果
    cy.get('[data-cy="filter-tab-songs"]').click()
    cy.get('[data-cy="search-result"]').should('have.length.greaterThan', 0)
    
    // 6. 播放搜索结果
    cy.get('[data-cy="search-result"]').first().click()
    cy.get('[data-cy="mini-player"]').should('be.visible')
  })

  it('创建和管理播放列表流程', () => {
    // 1. 登录（假设已有用户）
    cy.login('testuser', 'testpass123')
    
    // 2. 进入音乐库
    cy.get('[data-cy="tab-library"]').click()
    
    // 3. 创建新播放列表
    cy.get('[data-cy="create-playlist"]').click()
    cy.get('[data-cy="playlist-name"]').type('我的测试播放列表')
    cy.get('[data-cy="playlist-description"]').type('测试播放列表描述')
    cy.get('[data-cy="create-playlist-submit"]').click()
    
    // 4. 验证播放列表创建成功
    cy.contains('我的测试播放列表').should('be.visible')
    
    // 5. 添加歌曲到播放列表
    cy.visit('/pages/index/index')
    cy.get('[data-cy="content-card"]').first().within(() => {
      cy.get('[data-cy="more-button"]').click()
    })
    cy.get('[data-cy="add-to-playlist"]').click()
    cy.contains('我的测试播放列表').click()
    
    // 6. 验证歌曲添加成功
    cy.get('[data-cy="toast"]').should('contain', '添加成功')
    
    // 7. 查看播放列表内容
    cy.get('[data-cy="tab-library"]').click()
    cy.contains('我的测试播放列表').click()
    cy.get('[data-cy="playlist-track"]').should('have.length', 1)
  })

  it('语音搜索功能测试', () => {
    // 1. 进入搜索页面
    cy.get('[data-cy="search-button"]').click()
    
    // 2. 点击语音搜索按钮
    cy.get('[data-cy="voice-search"]').click()
    
    // 3. 模拟语音输入
    cy.window().then((win) => {
      // 模拟语音识别结果
      win.mockVoiceInput('播放流行音乐')
    })
    
    // 4. 验证语音指令执行
    cy.get('[data-cy="search-input"]').should('have.value', '流行音乐')
    cy.get('[data-cy="search-result"]').should('be.visible')
  })

  it('设置和偏好配置测试', () => {
    // 1. 登录
    cy.login('testuser', 'testpass123')
    
    // 2. 进入个人中心
    cy.get('[data-cy="tab-profile"]').click()
    
    // 3. 打开设置
    cy.get('[data-cy="settings-button"]').click()
    
    // 4. 修改音频质量设置
    cy.get('[data-cy="audio-quality"]').select('high')
    
    // 5. 开启自动播放
    cy.get('[data-cy="auto-play-toggle"]').click()
    
    // 6. 修改主题设置
    cy.get('[data-cy="theme-selector"]').select('dark')
    
    // 7. 保存设置
    cy.get('[data-cy="save-settings"]').click()
    cy.get('[data-cy="toast"]').should('contain', '设置保存成功')
    
    // 8. 验证设置生效
    cy.get('body').should('have.class', 'dark-theme')
  })
})

// 自定义命令
Cypress.Commands.add('login', (username, password) => {
  cy.get('[data-cy="login-button"]').click()
  cy.get('[data-cy="login-username"]').type(username)
  cy.get('[data-cy="login-password"]').type(password)
  cy.get('[data-cy="login-submit"]').click()
  cy.url().should('include', '/pages/index/index')
})

Cypress.Commands.add('mockVoiceInput', (text) => {
  cy.window().its('voiceCommandManager').then((manager) => {
    manager.handleRecognitionResult({
      transcript: text,
      isFinal: true
    })
  })
})
```

### 5.2 跨平台兼容性测试

#### 多端测试配置
```javascript
// cypress/support/commands.js

// 模拟不同设备
Cypress.Commands.add('setDevice', (device) => {
  const devices = {
    'iphone-x': { width: 375, height: 812, userAgent: 'iPhone' },
    'ipad': { width: 768, height: 1024, userAgent: 'iPad' },
    'android': { width: 360, height: 640, userAgent: 'Android' },
    'desktop': { width: 1920, height: 1080, userAgent: 'Chrome' }
  }
  
  const config = devices[device]
  if (config) {
    cy.viewport(config.width, config.height)
    cy.window().then((win) => {
      Object.defineProperty(win.navigator, 'userAgent', {
        value: config.userAgent,
        configurable: true
      })
    })
  }
})

// 测试响应式布局
Cypress.Commands.add('testResponsive', () => {
  const viewports = [
    { width: 320, height: 568 },  // iPhone SE
    { width: 375, height: 812 },  // iPhone X
    { width: 768, height: 1024 }, // iPad
    { width: 1920, height: 1080 } // Desktop
  ]
  
  viewports.forEach((viewport) => {
    cy.viewport(viewport.width, viewport.height)
    cy.get('[data-cy="main-content"]').should('be.visible')
    cy.get('[data-cy="navigation"]').should('be.visible')
  })
})
```

---

## 6. 测试自动化流程

### 6.1 CI/CD集成

#### GitHub Actions配置
```yaml
# .github/workflows/test.yml
name: 羊咩快报测试流程

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  backend-tests:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: yangmie_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      redis:
        image: redis:6
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: Install dependencies
      run: |
        cd backend
        pip install -r requirements/test.txt
    
    - name: Run linting
      run: |
        cd backend
        flake8 .
        black --check .
        isort --check-only .
    
    - name: Run unit tests
      run: |
        cd backend
        python manage.py test --settings=yangmie.settings.testing
      env:
        DATABASE_URL: postgres://postgres:postgres@localhost:5432/yangmie_test
        REDIS_URL: redis://localhost:6379/0
    
    - name: Run integration tests
      run: |
        cd backend
        pytest tests/integration/ -v
      env:
        DATABASE_URL: postgres://postgres:postgres@localhost:5432/yangmie_test
        REDIS_URL: redis://localhost:6379/0
    
    - name: Generate coverage report
      run: |
        cd backend
        coverage run --source='.' manage.py test
        coverage xml
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./backend/coverage.xml

  frontend-tests:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '16'
        cache: 'npm'
    
    - name: Install dependencies
      run: |
        cd frontend
        npm ci
    
    - name: Run linting
      run: |
        cd frontend
        npm run lint
    
    - name: Run unit tests
      run: |
        cd frontend
        npm run test:unit
    
    - name: Run integration tests
      run: |
        cd frontend
        npm run test:integration
    
    - name: Build application
      run: |
        cd frontend
        npm run build

  e2e-tests:
    runs-on: ubuntu-latest
    needs: [backend-tests, frontend-tests]
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '16'
        cache: 'npm'
    
    - name: Install dependencies
      run: |
        cd frontend
        npm ci
    
    - name: Start test environment
      run: |
        cd frontend
        npm run start:test &
        sleep 30
    
    - name: Run E2E tests
      run: |
        cd frontend
        npm run test:e2e:headless
    
    - name: Upload test artifacts
      uses: actions/upload-artifact@v3
      if: failure()
      with:
        name: cypress-screenshots
        path: frontend/cypress/screenshots

  performance-tests:
    runs-on: ubuntu-latest
    needs: [backend-tests, frontend-tests]
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '16'
        cache: 'npm'
    
    - name: Install k6
      run: |
        sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
        echo "deb https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
        sudo apt-get update
        sudo apt-get install k6
    
    - name: Run load tests
      run: |
        k6 run tests/performance/load-test.js
    
    - name: Run Lighthouse tests
      run: |
        npm install -g lighthouse
        cd tests/performance
        node lighthouse-test.js
    
    - name: Upload performance reports
      uses: actions/upload-artifact@v3
      with:
        name: performance-reports
        path: |
          lighthouse-*.html
          performance-report.json

  security-scan:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Run security scan
      uses: securecodewarrior/github-action-add-sarif@v1
      with:
        sarif-file: security-scan-results.sarif
    
    - name: Run dependency check
      run: |
        cd backend
        pip install safety
        safety check
        
        cd ../frontend
        npm audit --audit-level moderate
```

### 6.2 测试报告和监控

#### 测试报告生成
```javascript
// scripts/generate-test-report.js
const fs = require('fs')
const path = require('path')

class TestReportGenerator {
  constructor() {
    this.results = {
      backend: {
        unit: null,
        integration: null,
        coverage: null
      },
      frontend: {
        unit: null,
        integration: null,
        e2e: null
      },
      performance: {
        load: null,
        lighthouse: null
      }
    }
  }

  async generateReport() {
    try {
      await this.collectTestResults()
      await this.generateHTMLReport()
      await this.generateSlackReport()
      await this.uploadToS3()
    } catch (error) {
      console.error('生成测试报告失败:', error)
    }
  }

  async collectTestResults() {
    // 收集后端测试结果
    if (fs.existsSync('backend/test-results.xml')) {
      this.results.backend.unit = this.parseJUnitXML('backend/test-results.xml')
    }

    // 收集前端测试结果
    if (fs.existsSync('frontend/test-results.json')) {
      this.results.frontend.unit = JSON.parse(
        fs.readFileSync('frontend/test-results.json', 'utf8')
      )
    }

    // 收集性能测试结果
    if (fs.existsSync('performance-report.json')) {
      this.results.performance.lighthouse = JSON.parse(
        fs.readFileSync('performance-report.json', 'utf8')
      )
    }
  }

  async generateHTMLReport() {
    const template = this.getHTMLTemplate()
    const html = this.populateTemplate(template, this.results)
    
    fs.writeFileSync('test-report.html', html)
    console.log('✅ HTML测试报告已生成: test-report.html')
  }

  getHTMLTemplate() {
    return `
    <!DOCTYPE html>
    <html>
    <head>
      <title>羊咩快报 - 测试报告</title>
      <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { background: #4CD964; color: white; padding: 20px; border-radius: 8px; }
        .section { margin: 20px 0; padding: 20px; border: 1px solid #ddd; border-radius: 8px; }
        .pass { color: #4CD964; }
        .fail { color: #ff3b30; }
        .metric { display: flex; justify-content: space-between; margin: 10px 0; }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }
        th { background-color: #f5f5f5; }
      </style>
    </head>
    <body>
      <div class="header">
        <h1>羊咩快报 - 测试报告</h1>
        <p>生成时间: {{timestamp}}</p>
        <p>总体状态: <span class="{{overallStatus}}">{{overallStatusText}}</span></p>
      </div>

      <div class="section">
        <h2>📊 测试概况</h2>
        <div class="metric">
          <span>单元测试:</span>
          <span class="{{unitTestStatus}}">{{unitTestResult}}</span>
        </div>
        <div class="metric">
          <span>集成测试:</span>
          <span class="{{integrationTestStatus}}">{{integrationTestResult}}</span>
        </div>
        <div class="metric">
          <span>E2E测试:</span>
          <span class="{{e2eTestStatus}}">{{e2eTestResult}}</span>
        </div>
        <div class="metric">
          <span>代码覆盖率:</span>
          <span>{{coveragePercentage}}%</span>
        </div>
      </div>

      <div class="section">
        <h2>🚀 性能测试</h2>
        <table>
          <tr>
            <th>页面</th>
            <th>性能评分</th>
            <th>可访问性</th>
            <th>首屏渲染</th>
            <th>最大内容渲染</th>
          </tr>
          {{performanceRows}}
        </table>
      </div>

      <div class="section">
        <h2>🔍 详细结果</h2>
        <h3>失败的测试用例</h3>
        {{failedTests}}
      </div>
    </body>
    </html>
    `
  }

  populateTemplate(template, results) {
    const data = this.calculateSummary(results)
    
    return template
      .replace('{{timestamp}}', new Date().toLocaleString())
      .replace('{{overallStatus}}', data.overallStatus)
      .replace('{{overallStatusText}}', data.overallStatusText)
      .replace('{{unitTestStatus}}', data.unitTestStatus)
      .replace('{{unitTestResult}}', data.unitTestResult)
      .replace('{{integrationTestStatus}}', data.integrationTestStatus)
      .replace('{{integrationTestResult}}', data.integrationTestResult)
      .replace('{{e2eTestStatus}}', data.e2eTestStatus)
      .replace('{{e2eTestResult}}', data.e2eTestResult)
      .replace('{{coveragePercentage}}', data.coveragePercentage)
      .replace('{{performanceRows}}', data.performanceRows)
      .replace('{{failedTests}}', data.failedTests)
  }

  calculateSummary(results) {
    // 计算测试总结数据
    const summary = {
      totalTests: 0,
      passedTests: 0,
      failedTests: 0,
      coveragePercentage: 0,
      overallStatus: 'pass',
      overallStatusText: '通过'
    }

    // 统计各类测试结果
    if (results.backend.unit) {
      summary.totalTests += results.backend.unit.total
      summary.passedTests += results.backend.unit.passed
      summary.failedTests += results.backend.unit.failed
    }

    if (results.frontend.unit) {
      summary.totalTests += results.frontend.unit.numTotalTests
      summary.passedTests += results.frontend.unit.numPassedTests
      summary.failedTests += results.frontend.unit.numFailedTests
    }

    // 计算通过率
    const passRate = summary.totalTests > 0 ? 
      (summary.passedTests / summary.totalTests) * 100 : 0

    if (passRate < 95 || summary.failedTests > 0) {
      summary.overallStatus = 'fail'
      summary.overallStatusText = '失败'
    }

    return {
      ...summary,
      unitTestStatus: summary.failedTests === 0 ? 'pass' : 'fail',
      unitTestResult: `${summary.passedTests}/${summary.totalTests}`,
      integrationTestStatus: 'pass', // 从结果中获取
      integrationTestResult: '通过',
      e2eTestStatus: 'pass', // 从结果中获取
      e2eTestResult: '通过',
      coveragePercentage: 85, // 从覆盖率报告中获取
      performanceRows: this.generatePerformanceRows(results.performance),
      failedTests: this.generateFailedTestsList(results)
    }
  }

  generatePerformanceRows(performanceResults) {
    if (!performanceResults.lighthouse) return '<tr><td colspan="5">无性能数据</td></tr>'

    return performanceResults.lighthouse.details.map(page => `
      <tr>
        <td>${page.page}</td>
        <td class="${page.performance > 90 ? 'pass' : 'fail'}">${page.performance}</td>
        <td class="${page.accessibility > 95 ? 'pass' : 'fail'}">${page.accessibility}</td>
        <td>${page.firstContentfulPaint}ms</td>
        <td>${page.largestContentfulPaint}ms</td>
      </tr>
    `).join('')
  }

  generateFailedTestsList(results) {
    const failedTests = []
    
    // 收集失败的测试用例
    if (results.backend.unit && results.backend.unit.failures) {
      failedTests.push(...results.backend.unit.failures)
    }

    if (failedTests.length === 0) {
      return '<p class="pass">✅ 所有测试用例都通过了！</p>'
    }

    return `
      <ul>
        ${failedTests.map(test => `
          <li class="fail">
            <strong>${test.name}</strong><br>
            <small>${test.message}</small>
          </li>
        `).join('')}
      </ul>
    `
  }

  async generateSlackReport() {
    const summary = this.calculateSummary(this.results)
    
    const slackMessage = {
      text: '羊咩快报测试报告',
      blocks: [
        {
          type: 'header',
          text: {
            type: 'plain_text',
            text: '🧪 羊咩快报测试报告'
          }
        },
        {
          type: 'section',
          fields: [
            {
              type: 'mrkdwn',
              text: `*总体状态:* ${summary.overallStatus === 'pass' ? '✅ 通过' : '❌ 失败'}`
            },
            {
              type: 'mrkdwn',
              text: `*测试用例:* ${summary.passedTests}/${summary.totalTests}`
            },
            {
              type: 'mrkdwn',
              text: `*代码覆盖率:* ${summary.coveragePercentage}%`
            },
            {
              type: 'mrkdwn',
              text: `*生成时间:* ${new Date().toLocaleString()}`
            }
          ]
        }
      ]
    }

    // 保存Slack消息到文件，由CI流程发送
    fs.writeFileSync('slack-report.json', JSON.stringify(slackMessage, null, 2))
  }

  parseJUnitXML(filePath) {
    // 解析JUnit XML格式的测试结果
    const xml = fs.readFileSync(filePath, 'utf8')
    // 这里简化处理，实际应该使用XML解析器
    return {
      total: 100,
      passed: 95,
      failed: 5,
      failures: []
    }
  }
}

// 运行报告生成
if (require.main === module) {
  const generator = new TestReportGenerator()
  generator.generateReport().catch(console.error)
}

module.exports = TestReportGenerator
```

---

## 7. 测试最佳实践

### 7.1 测试编写原则

1. **AAA模式** - Arrange, Act, Assert
2. **单一职责** - 每个测试只验证一个功能点
3. **独立性** - 测试之间不应该有依赖关系
4. **可读性** - 测试名称和内容要清晰易懂
5. **可维护性** - 避免重复代码，使用适当的抽象

### 7.2 测试数据管理

```python
# 测试数据工厂
# tests/factories.py
import factory
from apps.users.models import User
from apps.content.models import AudioContent, Artist

class UserFactory(factory.django.DjangoModelFactory):
    class Meta:
        model = User

    username = factory.Sequence(lambda n: f"user{n}")
    email = factory.LazyAttribute(lambda obj: f"{obj.username}@example.com")
    nickname = factory.Faker('name')
    is_active = True

class ArtistFactory(factory.django.DjangoModelFactory):
    class Meta:
        model = Artist

    name = factory.Faker('name')
    bio = factory.Faker('text', max_nb_chars=200)
    is_verified = True

class AudioContentFactory(factory.django.DjangoModelFactory):
    class Meta:
        model = AudioContent

    title = factory.Faker('sentence', nb_words=3)
    description = factory.Faker('text', max_nb_chars=500)
    audio_url = factory.Faker('url')
    artist = factory.SubFactory(ArtistFactory)
    duration = factory.Faker('random_int', min=60, max=600)
    is_active = True
```

### 7.3 Mock和测试替身

```javascript
// 前端测试Mock
// tests/mocks/api.js
export const mockApi = {
  content: {
    getRecommended: jest.fn().mockResolvedValue({
      success: true,
      data: {
        results: [
          {
            id: 1,
            title: 'Mock Audio 1',
            artist: { name: 'Mock Artist 1' }
          }
        ]
      }
    }),
    
    search: jest.fn().mockResolvedValue({
      success: true,
      data: {
        results: [],
        pagination: { total: 0 }
      }
    })
  },
  
  player: {
    recordPlay: jest.fn().mockResolvedValue({
      success: true
    })
  }
}

// 音频Context Mock
export const mockAudioContext = {
  play: jest.fn().mockResolvedValue(),
  pause: jest.fn(),
  stop: jest.fn(),
  seek: jest.fn(),
  destroy: jest.fn(),
  onPlay: jest.fn(),
  onPause: jest.fn(),
  onTimeUpdate: jest.fn(),
  onEnded: jest.fn(),
  onError: jest.fn(),
  currentTime: 0,
  duration: 180,
  volume: 1
}
```

---

*此文档随开发进展和测试实践持续更新*