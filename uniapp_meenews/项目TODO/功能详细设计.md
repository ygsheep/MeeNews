# 羊咩快报 - 功能详细设计

## 功能设计概述

基于UI设计稿和项目需求分析，详细设计每个功能模块的交互流程、业务逻辑和技术实现方案。

---

## 1. 用户认证与账户管理

### 1.1 用户注册流程

#### 交互流程
1. 用户点击"注册"按钮
2. 填写注册信息（用户名、邮箱、密码、手机号）
3. 系统验证信息格式和唯一性
4. 发送验证码到邮箱/手机
5. 用户输入验证码完成验证
6. 创建用户账户并自动登录
7. 跳转到首页或引导页

#### 业务规则
- 用户名：3-20字符，支持中英文、数字、下划线
- 密码：至少8位，包含字母和数字
- 邮箱：标准邮箱格式验证
- 手机号：中国大陆手机号格式

#### 技术实现
```javascript
// 前端验证
const validateRegistration = (formData) => {
  const rules = {
    username: /^[\w\u4e00-\u9fa5]{3,20}$/,
    email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
    password: /^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d@$!%*#?&]{8,}$/,
    phone: /^1[3-9]\d{9}$/
  }
  
  for (let field in rules) {
    if (!rules[field].test(formData[field])) {
      return { valid: false, field, message: `${field}格式不正确` }
    }
  }
  
  return { valid: true }
}

// 注册API调用
const register = async (userData) => {
  try {
    const response = await api.auth.register(userData)
    if (response.success) {
      // 保存token
      uni.setStorageSync('token', response.data.token.access)
      uni.setStorageSync('refresh_token', response.data.token.refresh)
      
      // 跳转首页
      uni.reLaunch({ url: '/pages/index/index' })
    }
  } catch (error) {
    uni.showToast({
      title: error.message || '注册失败',
      icon: 'error'
    })
  }
}
```

### 1.2 用户登录流程

#### 支持的登录方式
1. **用户名/邮箱 + 密码**
2. **手机号 + 验证码**
3. **第三方登录**（微信、QQ、微博）
4. **生物识别登录**（指纹、面部识别）

#### 登录状态管理
```javascript
// Pinia Store
export const useUserStore = defineStore('user', {
  state: () => ({
    userInfo: null,
    token: '',
    refreshToken: '',
    isLoggedIn: false,
    loginMethod: '', // password | sms | wechat | fingerprint
    lastLoginTime: null
  }),

  actions: {
    async login(credentials, method = 'password') {
      try {
        const response = await api.auth.login(credentials)
        
        this.token = response.data.token.access
        this.refreshToken = response.data.token.refresh
        this.userInfo = response.data.user
        this.isLoggedIn = true
        this.loginMethod = method
        this.lastLoginTime = new Date().toISOString()
        
        // 持久化存储
        this.persistUserData()
        
        // 初始化用户偏好
        await this.loadUserPreferences()
        
        return response
      } catch (error) {
        throw error
      }
    },

    async refreshAccessToken() {
      try {
        const response = await api.auth.refresh({
          refresh: this.refreshToken
        })
        
        this.token = response.data.access
        uni.setStorageSync('token', this.token)
        
        return response
      } catch (error) {
        // 刷新失败，重新登录
        this.logout()
        throw error
      }
    },

    logout() {
      this.userInfo = null
      this.token = ''
      this.refreshToken = ''
      this.isLoggedIn = false
      
      // 清除本地存储
      uni.removeStorageSync('token')
      uni.removeStorageSync('refresh_token')
      uni.removeStorageSync('user_info')
      
      // 跳转登录页
      uni.reLaunch({ url: '/pages/auth/login' })
    }
  }
})
```

---

## 2. 音频播放核心功能

### 2.1 播放器架构设计

#### 播放器状态管理
```javascript
export const usePlayerStore = defineStore('player', {
  state: () => ({
    // 播放状态
    currentTrack: null,
    isPlaying: false,
    isPaused: false,
    isLoading: false,
    
    // 时间控制
    currentTime: 0,
    duration: 0,
    bufferedTime: 0,
    
    // 播放控制
    volume: 1.0,
    playbackRate: 1.0,
    shuffleMode: false,
    repeatMode: 'none', // none | one | all
    
    // 播放列表
    currentPlaylist: null,
    currentIndex: 0,
    playQueue: [],
    playHistory: [],
    
    // 音频对象
    audioContext: null,
    
    // 播放模式
    playMode: 'sequence', // sequence | shuffle | single
    
    // 错误状态
    error: null,
    
    // 网络状态
    networkType: 'unknown',
    isOnline: true
  }),

  getters: {
    // 播放进度百分比
    progressPercent: (state) => {
      if (state.duration === 0) return 0
      return (state.currentTime / state.duration) * 100
    },
    
    // 缓冲进度百分比
    bufferedPercent: (state) => {
      if (state.duration === 0) return 0
      return (state.bufferedTime / state.duration) * 100
    },
    
    // 是否可以播放上一首
    canPlayPrevious: (state) => {
      return state.currentIndex > 0 || 
             state.repeatMode === 'all' || 
             state.playHistory.length > 0
    },
    
    // 是否可以播放下一首
    canPlayNext: (state) => {
      return state.currentIndex < state.playQueue.length - 1 || 
             state.repeatMode === 'all'
    },
    
    // 格式化当前时间
    formattedCurrentTime: (state) => {
      return formatTime(state.currentTime)
    },
    
    // 格式化总时长
    formattedDuration: (state) => {
      return formatTime(state.duration)
    }
  },

  actions: {
    // 播放音频
    async playTrack(track, playlist = null, index = 0) {
      try {
        this.isLoading = true
        this.error = null
        
        // 如果是新的音频，需要重新初始化
        if (!this.currentTrack || this.currentTrack.id !== track.id) {
          await this.initializeAudio(track)
        }
        
        // 设置播放列表
        if (playlist) {
          this.currentPlaylist = playlist
          this.playQueue = playlist.tracks || [track]
          this.currentIndex = index
        } else {
          this.playQueue = [track]
          this.currentIndex = 0
        }
        
        this.currentTrack = track
        
        // 开始播放
        await this.play()
        
        // 记录播放历史
        this.addToHistory(track)
        
        // 上报播放数据
        this.reportPlayStart(track)
        
      } catch (error) {
        this.handlePlayError(error)
      } finally {
        this.isLoading = false
      }
    },

    // 初始化音频
    async initializeAudio(track) {
      // 销毁之前的音频对象
      if (this.audioContext) {
        this.audioContext.destroy()
      }
      
      // 创建新的音频对象
      this.audioContext = uni.createInnerAudioContext()
      
      // 设置音频源
      this.audioContext.src = track.audio_url
      this.audioContext.volume = this.volume
      this.audioContext.playbackRate = this.playbackRate
      
      // 绑定事件
      this.bindAudioEvents()
      
      // 预加载
      return new Promise((resolve, reject) => {
        this.audioContext.onCanplay(() => {
          this.duration = this.audioContext.duration || track.duration
          resolve()
        })
        
        this.audioContext.onError((error) => {
          reject(error)
        })
      })
    },

    // 绑定音频事件
    bindAudioEvents() {
      if (!this.audioContext) return
      
      // 播放事件
      this.audioContext.onPlay(() => {
        this.isPlaying = true
        this.isPaused = false
      })
      
      // 暂停事件
      this.audioContext.onPause(() => {
        this.isPlaying = false
        this.isPaused = true
      })
      
      // 停止事件
      this.audioContext.onStop(() => {
        this.isPlaying = false
        this.isPaused = false
      })
      
      // 时间更新
      this.audioContext.onTimeUpdate(() => {
        this.currentTime = this.audioContext.currentTime
        this.duration = this.audioContext.duration
        
        // 更新播放进度到服务器
        this.reportPlayProgress()
      })
      
      // 播放完成
      this.audioContext.onEnded(() => {
        this.handleTrackEnded()
      })
      
      // 错误处理
      this.audioContext.onError((error) => {
        this.handlePlayError(error)
      })
      
      // 等待数据
      this.audioContext.onWaiting(() => {
        this.isLoading = true
      })
      
      // 可以播放
      this.audioContext.onCanplay(() => {
        this.isLoading = false
      })
    },

    // 播放/暂停控制
    async togglePlay() {
      if (!this.audioContext) return
      
      try {
        if (this.isPlaying) {
          this.audioContext.pause()
        } else {
          await this.audioContext.play()
        }
      } catch (error) {
        this.handlePlayError(error)
      }
    },

    // 播放
    async play() {
      if (this.audioContext) {
        await this.audioContext.play()
      }
    },

    // 暂停
    pause() {
      if (this.audioContext) {
        this.audioContext.pause()
      }
    },

    // 停止
    stop() {
      if (this.audioContext) {
        this.audioContext.stop()
        this.currentTime = 0
      }
    },

    // 跳转到指定时间
    seek(time) {
      if (this.audioContext && time >= 0 && time <= this.duration) {
        this.audioContext.seek(time)
        this.currentTime = time
      }
    },

    // 设置音量
    setVolume(volume) {
      this.volume = Math.max(0, Math.min(1, volume))
      if (this.audioContext) {
        this.audioContext.volume = this.volume
      }
    },

    // 设置播放速度
    setPlaybackRate(rate) {
      this.playbackRate = Math.max(0.5, Math.min(2, rate))
      if (this.audioContext) {
        this.audioContext.playbackRate = this.playbackRate
      }
    },

    // 播放下一首
    async playNext() {
      let nextIndex = this.getNextTrackIndex()
      
      if (nextIndex !== -1) {
        const nextTrack = this.playQueue[nextIndex]
        await this.playTrack(nextTrack, this.currentPlaylist, nextIndex)
      }
    },

    // 播放上一首
    async playPrevious() {
      let prevIndex = this.getPreviousTrackIndex()
      
      if (prevIndex !== -1) {
        const prevTrack = this.playQueue[prevIndex]
        await this.playTrack(prevTrack, this.currentPlaylist, prevIndex)
      }
    },

    // 获取下一首音轨索引
    getNextTrackIndex() {
      if (this.shuffleMode) {
        // 随机模式
        const availableIndexes = this.playQueue
          .map((_, index) => index)
          .filter(index => index !== this.currentIndex)
        return availableIndexes[Math.floor(Math.random() * availableIndexes.length)]
      } else {
        // 顺序模式
        if (this.currentIndex < this.playQueue.length - 1) {
          return this.currentIndex + 1
        } else if (this.repeatMode === 'all') {
          return 0
        }
      }
      return -1
    },

    // 获取上一首音轨索引
    getPreviousTrackIndex() {
      if (this.currentIndex > 0) {
        return this.currentIndex - 1
      } else if (this.repeatMode === 'all') {
        return this.playQueue.length - 1
      }
      return -1
    },

    // 切换随机播放
    toggleShuffle() {
      this.shuffleMode = !this.shuffleMode
      
      if (this.shuffleMode) {
        // 重新排列播放队列
        this.shufflePlayQueue()
      } else {
        // 恢复原始顺序
        this.restorePlayQueueOrder()
      }
    },

    // 切换重复模式
    toggleRepeat() {
      const modes = ['none', 'one', 'all']
      const currentIndex = modes.indexOf(this.repeatMode)
      this.repeatMode = modes[(currentIndex + 1) % modes.length]
    },

    // 处理音轨播放结束
    async handleTrackEnded() {
      // 记录播放完成
      this.reportPlayComplete()
      
      if (this.repeatMode === 'one') {
        // 单曲循环
        this.seek(0)
        await this.play()
      } else {
        // 播放下一首
        await this.playNext()
      }
    },

    // 处理播放错误
    handlePlayError(error) {
      console.error('播放错误:', error)
      this.error = error.message || '播放失败'
      this.isPlaying = false
      this.isLoading = false
      
      uni.showToast({
        title: '播放失败',
        icon: 'error'
      })
      
      // 尝试播放下一首
      setTimeout(() => {
        this.playNext()
      }, 2000)
    },

    // 添加到播放历史
    addToHistory(track) {
      const historyItem = {
        ...track,
        playedAt: new Date().toISOString()
      }
      
      // 避免重复添加
      const existingIndex = this.playHistory.findIndex(item => item.id === track.id)
      if (existingIndex !== -1) {
        this.playHistory.splice(existingIndex, 1)
      }
      
      this.playHistory.unshift(historyItem)
      
      // 限制历史记录数量
      if (this.playHistory.length > 1000) {
        this.playHistory = this.playHistory.slice(0, 1000)
      }
      
      // 保存到本地存储
      uni.setStorageSync('play_history', this.playHistory)
    },

    // 上报播放开始
    async reportPlayStart(track) {
      try {
        await api.player.recordPlay({
          content_id: track.id,
          action: 'start',
          timestamp: new Date().toISOString(),
          device_type: this.getDeviceType()
        })
      } catch (error) {
        console.error('上报播放开始失败:', error)
      }
    },

    // 上报播放进度
    throttledReportProgress: null,
    
    reportPlayProgress() {
      if (!this.throttledReportProgress) {
        this.throttledReportProgress = throttle(async () => {
          if (this.currentTrack && this.isPlaying) {
            try {
              await api.player.updateProgress({
                content_id: this.currentTrack.id,
                current_time: this.currentTime,
                duration: this.duration,
                progress_percent: this.progressPercent
              })
            } catch (error) {
              console.error('上报播放进度失败:', error)
            }
          }
        }, 10000) // 每10秒上报一次
      }
      
      this.throttledReportProgress()
    },

    // 上报播放完成
    async reportPlayComplete() {
      if (this.currentTrack) {
        try {
          await api.player.recordPlay({
            content_id: this.currentTrack.id,
            action: 'complete',
            play_duration: this.currentTime,
            completion_rate: (this.currentTime / this.duration) * 100,
            timestamp: new Date().toISOString()
          })
        } catch (error) {
          console.error('上报播放完成失败:', error)
        }
      }
    },

    // 获取设备类型
    getDeviceType() {
      const systemInfo = uni.getSystemInfoSync()
      return systemInfo.platform || 'unknown'
    },

    // 销毁播放器
    destroy() {
      if (this.audioContext) {
        this.audioContext.destroy()
        this.audioContext = null
      }
      
      this.currentTrack = null
      this.isPlaying = false
      this.currentTime = 0
      this.duration = 0
    }
  }
})
```

### 2.2 音频缓存和预加载策略

#### 智能预加载
```javascript
class AudioPreloader {
  constructor() {
    this.preloadQueue = []
    this.preloadedTracks = new Map()
    this.maxPreloadSize = 50 * 1024 * 1024 // 50MB
    this.currentPreloadSize = 0
  }

  // 预加载下一首歌曲
  async preloadNext(currentIndex, playlist) {
    const nextIndex = (currentIndex + 1) % playlist.length
    const nextTrack = playlist[nextIndex]
    
    if (nextTrack && !this.preloadedTracks.has(nextTrack.id)) {
      await this.preloadTrack(nextTrack)
    }
  }

  // 预加载单个音轨
  async preloadTrack(track) {
    try {
      // 检查网络状况
      const networkType = await this.getNetworkType()
      if (networkType === '2g' || networkType === 'slow-2g') {
        return // 网络太慢，跳过预加载
      }

      // 检查存储空间
      if (this.currentPreloadSize >= this.maxPreloadSize) {
        this.clearOldestPreload()
      }

      // 创建音频对象进行预加载
      const audio = uni.createInnerAudioContext()
      audio.src = track.audio_url
      
      return new Promise((resolve, reject) => {
        audio.onCanplay(() => {
          this.preloadedTracks.set(track.id, {
            track,
            audio,
            loadedAt: Date.now(),
            size: track.file_size || 0
          })
          
          this.currentPreloadSize += track.file_size || 0
          resolve()
        })
        
        audio.onError(reject)
        
        // 超时处理
        setTimeout(() => {
          reject(new Error('预加载超时'))
        }, 30000)
      })
    } catch (error) {
      console.error('预加载失败:', error)
    }
  }

  // 获取预加载的音频对象
  getPreloadedAudio(trackId) {
    return this.preloadedTracks.get(trackId)?.audio
  }

  // 清理最旧的预加载
  clearOldestPreload() {
    let oldest = null
    let oldestTime = Date.now()
    
    for (let [id, data] of this.preloadedTracks) {
      if (data.loadedAt < oldestTime) {
        oldest = id
        oldestTime = data.loadedAt
      }
    }
    
    if (oldest) {
      const data = this.preloadedTracks.get(oldest)
      data.audio.destroy()
      this.currentPreloadSize -= data.size
      this.preloadedTracks.delete(oldest)
    }
  }

  // 获取网络类型
  async getNetworkType() {
    return new Promise((resolve) => {
      uni.getNetworkType({
        success: (res) => resolve(res.networkType),
        fail: () => resolve('unknown')
      })
    })
  }
}
```

---

## 3. 搜索功能设计

### 3.1 智能搜索实现

#### 搜索建议和补全
```javascript
class SearchManager {
  constructor() {
    this.searchHistory = []
    this.searchSuggestions = []
    this.debounceTimer = null
    this.cacheManager = new Map()
  }

  // 搜索输入处理
  onSearchInput(query) {
    // 清除之前的防抖定时器
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer)
    }

    // 防抖处理
    this.debounceTimer = setTimeout(async () => {
      if (query.trim().length > 0) {
        await this.getSuggestions(query)
      } else {
        this.searchSuggestions = []
      }
    }, 300)
  }

  // 获取搜索建议
  async getSuggestions(query) {
    try {
      // 检查缓存
      if (this.cacheManager.has(query)) {
        this.searchSuggestions = this.cacheManager.get(query)
        return
      }

      const response = await api.search.getSuggestions({
        q: query,
        limit: 10
      })

      if (response.success) {
        this.searchSuggestions = response.data.suggestions
        
        // 缓存结果
        this.cacheManager.set(query, this.searchSuggestions)
        
        // 限制缓存大小
        if (this.cacheManager.size > 100) {
          const firstKey = this.cacheManager.keys().next().value
          this.cacheManager.delete(firstKey)
        }
      }
    } catch (error) {
      console.error('获取搜索建议失败:', error)
    }
  }

  // 执行搜索
  async performSearch(query, filters = {}) {
    try {
      // 添加到搜索历史
      this.addToHistory(query)

      const response = await api.search.search({
        q: query,
        type: filters.type || 'all',
        category_id: filters.categoryId,
        sort: filters.sort || 'relevance',
        page: filters.page || 1,
        page_size: filters.pageSize || 20
      })

      if (response.success) {
        return {
          results: response.data.results,
          total: response.data.pagination.total,
          hasMore: response.data.pagination.has_next,
          suggestions: response.data.suggestions || []
        }
      }
    } catch (error) {
      console.error('搜索失败:', error)
      throw error
    }
  }

  // 添加到搜索历史
  addToHistory(query) {
    // 移除重复项
    const index = this.searchHistory.indexOf(query)
    if (index !== -1) {
      this.searchHistory.splice(index, 1)
    }

    // 添加到开头
    this.searchHistory.unshift(query)

    // 限制历史记录数量
    if (this.searchHistory.length > 50) {
      this.searchHistory = this.searchHistory.slice(0, 50)
    }

    // 保存到本地存储
    uni.setStorageSync('search_history', this.searchHistory)
  }

  // 清空搜索历史
  clearHistory() {
    this.searchHistory = []
    uni.removeStorageSync('search_history')
  }

  // 从本地存储加载搜索历史
  loadHistory() {
    try {
      const history = uni.getStorageSync('search_history')
      if (history) {
        this.searchHistory = history
      }
    } catch (error) {
      console.error('加载搜索历史失败:', error)
    }
  }
}
```

### 3.2 搜索结果展示

#### 多类型搜索结果
```vue
<template>
  <view class="search-results">
    <!-- 搜索统计 -->
    <view class="search-stats">
      <text class="stats-text">找到 {{ totalResults }} 个结果</text>
      <text class="search-time">用时 {{ searchTime }}ms</text>
    </view>

    <!-- 分类筛选 -->
    <scroll-view scroll-x class="filter-tabs">
      <view class="filter-tab-list">
        <view 
          v-for="filter in filterTabs"
          :key="filter.type"
          class="filter-tab"
          :class="{ active: activeFilter === filter.type }"
          @click="setActiveFilter(filter.type)"
        >
          <text class="filter-name">{{ filter.name }}</text>
          <text class="filter-count" v-if="filter.count > 0">({{ filter.count }})</text>
        </view>
      </view>
    </scroll-view>

    <!-- 搜索结果 -->
    <view class="search-content">
      <!-- 综合结果 -->
      <template v-if="activeFilter === 'all'">
        <!-- 热门结果 -->
        <SearchSection title="热门结果" v-if="hotResults.length > 0">
          <ContentCard 
            v-for="item in hotResults"
            :key="`hot-${item.type}-${item.id}`"
            :content="item"
            card-type="list"
            @click="handleResultClick(item)"
          />
        </SearchSection>

        <!-- 歌曲结果 -->
        <SearchSection title="歌曲" v-if="songResults.length > 0" @more="setActiveFilter('song')">
          <ContentCard 
            v-for="song in songResults.slice(0, 3)"
            :key="`song-${song.id}`"
            :content="song"
            card-type="list"
            @click="playSong(song)"
          />
        </SearchSection>

        <!-- 艺术家结果 -->
        <SearchSection title="艺术家" v-if="artistResults.length > 0" @more="setActiveFilter('artist')">
          <scroll-view scroll-x class="artist-scroll">
            <view class="artist-list">
              <ArtistCard 
                v-for="artist in artistResults.slice(0, 5)"
                :key="`artist-${artist.id}`"
                :artist="artist"
                @click="goToArtist(artist.id)"
              />
            </view>
          </scroll-view>
        </SearchSection>

        <!-- 专辑结果 -->
        <SearchSection title="专辑" v-if="albumResults.length > 0" @more="setActiveFilter('album')">
          <scroll-view scroll-x class="album-scroll">
            <view class="album-list">
              <AlbumCard 
                v-for="album in albumResults.slice(0, 5)"
                :key="`album-${album.id}`"
                :album="album"
                @click="goToAlbum(album.id)"
              />
            </view>
          </scroll-view>
        </SearchSection>
      </template>

      <!-- 单类型结果 -->
      <template v-else>
        <view class="single-type-results">
          <ContentCard 
            v-for="item in filteredResults"
            :key="`${activeFilter}-${item.id}`"
            :content="item"
            :card-type="getCardType(activeFilter)"
            @click="handleResultClick(item)"
          />
        </view>

        <!-- 加载更多 -->
        <view class="load-more" v-if="hasMore">
          <fui-button 
            type="primary" 
            size="small" 
            :loading="loading"
            @click="loadMore"
          >
            加载更多
          </fui-button>
        </view>
      </template>
    </view>

    <!-- 空状态 -->
    <EmptyState 
      v-if="!loading && totalResults === 0"
      icon="search"
      title="没有找到相关结果"
      description="尝试使用其他关键词搜索"
    />
  </view>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue'
import { useRoute } from '@dcloudio/uni-app'

const route = useRoute()

// 数据定义
const query = ref('')
const activeFilter = ref('all')
const searchResults = ref({})
const totalResults = ref(0)
const searchTime = ref(0)
const loading = ref(false)
const hasMore = ref(false)
const currentPage = ref(1)

// 筛选标签
const filterTabs = ref([
  { type: 'all', name: '综合', count: 0 },
  { type: 'song', name: '歌曲', count: 0 },
  { type: 'artist', name: '艺术家', count: 0 },
  { type: 'album', name: '专辑', count: 0 },
  { type: 'playlist', name: '歌单', count: 0 }
])

// 计算属性
const hotResults = computed(() => searchResults.value.hot || [])
const songResults = computed(() => searchResults.value.songs || [])
const artistResults = computed(() => searchResults.value.artists || [])
const albumResults = computed(() => searchResults.value.albums || [])

const filteredResults = computed(() => {
  return searchResults.value[activeFilter.value] || []
})

// 方法定义
const performSearch = async (searchQuery = query.value, page = 1) => {
  try {
    loading.value = true
    const startTime = Date.now()

    const response = await searchManager.performSearch(searchQuery, {
      type: activeFilter.value,
      page,
      pageSize: 20
    })

    searchTime.value = Date.now() - startTime

    if (page === 1) {
      searchResults.value = response.results
      totalResults.value = response.total
    } else {
      // 追加结果
      const currentResults = searchResults.value[activeFilter.value] || []
      searchResults.value[activeFilter.value] = [...currentResults, ...response.results[activeFilter.value]]
    }

    hasMore.value = response.hasMore
    currentPage.value = page

    // 更新筛选标签计数
    updateFilterCounts(response.results)

  } catch (error) {
    uni.showToast({
      title: '搜索失败',
      icon: 'error'
    })
  } finally {
    loading.value = false
  }
}

const setActiveFilter = (filterType) => {
  activeFilter.value = filterType
  currentPage.value = 1

  if (filterType !== 'all' && (!searchResults.value[filterType] || searchResults.value[filterType].length === 0)) {
    performSearch(query.value, 1)
  }
}

const loadMore = () => {
  if (!loading.value && hasMore.value) {
    performSearch(query.value, currentPage.value + 1)
  }
}

const handleResultClick = (item) => {
  switch (item.type) {
    case 'song':
      playSong(item)
      break
    case 'artist':
      goToArtist(item.id)
      break
    case 'album':
      goToAlbum(item.id)
      break
    case 'playlist':
      goToPlaylist(item.id)
      break
  }
}

const playSong = (song) => {
  const playerStore = usePlayerStore()
  playerStore.playTrack(song)
}

// 生命周期
onMounted(() => {
  query.value = route.query.q || ''
  if (query.value) {
    performSearch()
  }
})
</script>
```

---

## 4. 个性化推荐系统

### 4.1 推荐算法设计

#### 多维度推荐策略
```python
# Django后端推荐算法实现
class RecommendationEngine:
    def __init__(self):
        self.weights = {
            'user_preference': 0.3,
            'collaborative_filtering': 0.25,
            'content_based': 0.2,
            'popularity': 0.15,
            'diversity': 0.1
        }
    
    def generate_recommendations(self, user_id, limit=20):
        """生成个性化推荐"""
        try:
            user = User.objects.get(id=user_id)
            
            # 获取用户行为数据
            user_behavior = self.get_user_behavior(user)
            
            # 多种推荐策略
            recommendations = []
            
            # 1. 基于用户偏好的推荐
            preference_recs = self.user_preference_based(user_behavior, limit // 4)
            recommendations.extend(self.add_score(preference_recs, 'user_preference'))
            
            # 2. 协同过滤推荐
            collaborative_recs = self.collaborative_filtering(user, limit // 4)
            recommendations.extend(self.add_score(collaborative_recs, 'collaborative_filtering'))
            
            # 3. 基于内容的推荐
            content_recs = self.content_based_filtering(user_behavior, limit // 4)
            recommendations.extend(self.add_score(content_recs, 'content_based'))
            
            # 4. 热门内容推荐
            popular_recs = self.popularity_based(user_behavior, limit // 4)
            recommendations.extend(self.add_score(popular_recs, 'popularity'))
            
            # 合并和排序
            final_recommendations = self.merge_and_rank(recommendations, limit)
            
            # 确保多样性
            diverse_recommendations = self.ensure_diversity(final_recommendations)
            
            return diverse_recommendations
            
        except Exception as e:
            logger.error(f"推荐生成失败: {e}")
            return self.fallback_recommendations(limit)
    
    def get_user_behavior(self, user):
        """获取用户行为数据"""
        behavior = {
            'play_history': PlayHistory.objects.filter(user=user).order_by('-created_at')[:1000],
            'favorites': UserFavorites.objects.filter(user=user, content_type='audio'),
            'ratings': UserRatings.objects.filter(user=user),
            'search_history': SearchHistory.objects.filter(user=user).order_by('-created_at')[:100],
            'skip_behavior': self.analyze_skip_behavior(user),
            'listening_time': self.get_listening_patterns(user)
        }
        return behavior
    
    def user_preference_based(self, behavior, limit):
        """基于用户偏好的推荐"""
        # 分析用户喜欢的类型、艺术家、风格
        favorite_categories = self.get_favorite_categories(behavior)
        favorite_artists = self.get_favorite_artists(behavior)
        
        recommendations = []
        
        # 根据喜欢的分类推荐
        for category, weight in favorite_categories.items():
            contents = AudioContent.objects.filter(
                category_id=category,
                is_active=True
            ).exclude(
                id__in=self.get_user_played_content_ids(behavior)
            ).order_by('-play_count')[:limit // len(favorite_categories)]
            
            for content in contents:
                recommendations.append({
                    'content': content,
                    'score': weight * 0.8,
                    'reason': f'因为您喜欢{content.category.name}'
                })
        
        return recommendations
    
    def collaborative_filtering(self, user, limit):
        """协同过滤推荐"""
        # 找到相似用户
        similar_users = self.find_similar_users(user)
        
        recommendations = []
        
        for similar_user, similarity in similar_users[:10]:
            # 获取相似用户喜欢但当前用户没有听过的音乐
            similar_user_favorites = UserFavorites.objects.filter(
                user=similar_user,
                content_type='audio'
            ).exclude(
                content_id__in=self.get_user_played_content_ids(
                    self.get_user_behavior(user)
                )
            )
            
            for favorite in similar_user_favorites[:limit // 10]:
                recommendations.append({
                    'content': favorite.content,
                    'score': similarity * 0.9,
                    'reason': f'喜欢相同音乐的用户也喜欢'
                })
        
        return recommendations
    
    def content_based_filtering(self, behavior, limit):
        """基于内容的推荐"""
        # 分析用户喜欢的音乐特征
        audio_features = self.analyze_audio_features(behavior)
        
        recommendations = []
        
        # 根据音频特征相似度推荐
        similar_contents = AudioContent.objects.filter(
            is_active=True
        ).exclude(
            id__in=self.get_user_played_content_ids(behavior)
        )
        
        for content in similar_contents:
            similarity = self.calculate_audio_similarity(
                audio_features, 
                content.get_audio_features()
            )
            
            if similarity > 0.7:
                recommendations.append({
                    'content': content,
                    'score': similarity,
                    'reason': f'与您喜欢的《{behavior["favorites"][0].content.title}》相似'
                })
        
        return sorted(recommendations, key=lambda x: x['score'], reverse=True)[:limit]
    
    def merge_and_rank(self, recommendations, limit):
        """合并和排序推荐结果"""
        # 去重
        seen_content_ids = set()
        unique_recommendations = []
        
        for rec in recommendations:
            content_id = rec['content'].id
            if content_id not in seen_content_ids:
                seen_content_ids.add(content_id)
                unique_recommendations.append(rec)
        
        # 计算最终分数
        for rec in unique_recommendations:
            strategy_weight = self.weights.get(rec.get('strategy', 'user_preference'), 0.1)
            rec['final_score'] = rec['score'] * strategy_weight
        
        # 排序
        unique_recommendations.sort(key=lambda x: x['final_score'], reverse=True)
        
        return unique_recommendations[:limit]
    
    def ensure_diversity(self, recommendations):
        """确保推荐结果的多样性"""
        if not recommendations:
            return []
        
        diverse_recs = []
        category_counts = {}
        artist_counts = {}
        
        for rec in recommendations:
            content = rec['content']
            category_id = content.category_id
            artist_id = content.artist_id
            
            # 限制每个分类和艺术家的推荐数量
            if (category_counts.get(category_id, 0) < 5 and 
                artist_counts.get(artist_id, 0) < 3):
                
                diverse_recs.append(rec)
                category_counts[category_id] = category_counts.get(category_id, 0) + 1
                artist_counts[artist_id] = artist_counts.get(artist_id, 0) + 1
        
        return diverse_recs
```

### 4.2 实时推荐更新

#### 用户行为实时分析
```javascript
// 前端行为追踪
class BehaviorTracker {
  constructor() {
    this.behaviorQueue = []
    this.uploadTimer = null
    this.maxQueueSize = 50
  }

  // 追踪播放行为
  trackPlay(contentId, context = {}) {
    this.addBehavior({
      type: 'play',
      content_id: contentId,
      timestamp: Date.now(),
      context: {
        source: context.source || 'unknown', // recommend, search, playlist
        position: context.position || 0,
        playlist_id: context.playlistId,
        session_id: this.getSessionId()
      }
    })
  }

  // 追踪跳过行为
  trackSkip(contentId, playedDuration, totalDuration) {
    this.addBehavior({
      type: 'skip',
      content_id: contentId,
      played_duration: playedDuration,
      total_duration: totalDuration,
      skip_percentage: (playedDuration / totalDuration) * 100,
      timestamp: Date.now()
    })
  }

  // 追踪收藏行为
  trackFavorite(contentId, action) {
    this.addBehavior({
      type: 'favorite',
      content_id: contentId,
      action: action, // add, remove
      timestamp: Date.now()
    })
  }

  // 追踪搜索行为
  trackSearch(query, results, selectedResult = null) {
    this.addBehavior({
      type: 'search',
      query: query,
      result_count: results.length,
      selected_result: selectedResult,
      timestamp: Date.now()
    })
  }

  // 追踪分享行为
  trackShare(contentId, platform) {
    this.addBehavior({
      type: 'share',
      content_id: contentId,
      platform: platform,
      timestamp: Date.now()
    })
  }

  // 添加行为到队列
  addBehavior(behavior) {
    this.behaviorQueue.push(behavior)

    // 队列满了或定时上传
    if (this.behaviorQueue.length >= this.maxQueueSize) {
      this.uploadBehaviors()
    } else if (!this.uploadTimer) {
      this.uploadTimer = setTimeout(() => {
        this.uploadBehaviors()
      }, 30000) // 30秒后上传
    }
  }

  // 上传行为数据
  async uploadBehaviors() {
    if (this.behaviorQueue.length === 0) return

    try {
      const behaviors = [...this.behaviorQueue]
      this.behaviorQueue = []

      await api.analytics.uploadBehaviors(behaviors)

      // 清除定时器
      if (this.uploadTimer) {
        clearTimeout(this.uploadTimer)
        this.uploadTimer = null
      }

    } catch (error) {
      console.error('上传行为数据失败:', error)
      
      // 失败时重新加入队列
      this.behaviorQueue.unshift(...behaviors)
    }
  }

  // 获取会话ID
  getSessionId() {
    let sessionId = uni.getStorageSync('session_id')
    if (!sessionId) {
      sessionId = this.generateSessionId()
      uni.setStorageSync('session_id', sessionId)
    }
    return sessionId
  }

  // 生成会话ID
  generateSessionId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2)
  }

  // 应用退出时上传剩余数据
  onAppHide() {
    this.uploadBehaviors()
  }
}

// 全局行为追踪器实例
export const behaviorTracker = new BehaviorTracker()

// 在App.vue中监听应用生命周期
export default {
  onHide() {
    behaviorTracker.onAppHide()
  },

  onUnload() {
    behaviorTracker.onAppHide()
  }
}
```

---

## 5. AI语音合成功能

### 5.1 TTS服务集成

#### 语音合成管理器
```javascript
class TTSManager {
  constructor() {
    this.apiEndpoint = 'https://nls-gateway.cn-shanghai.aliyuncs.com/stream/v1/tts'
    this.accessToken = ''
    this.voiceProfiles = {
      'standard_female': { name: '小云', voice: 'Xiaoyun', style: 'normal' },
      'standard_male': { name: '小明', voice: 'Xiaoming', style: 'normal' },
      'sweet_female': { name: '小美', voice: 'Xiaomei', style: 'sweet' },
      'professional_male': { name: '小强', voice: 'Xiaoqiang', style: 'professional' },
      'child_voice': { name: '小萌', voice: 'Xiaomeng', style: 'child' }
    }
    this.synthesisQueue = []
    this.isProcessing = false
  }

  // 初始化TTS服务
  async initialize() {
    try {
      // 获取访问令牌
      this.accessToken = await this.getAccessToken()
      return true
    } catch (error) {
      console.error('TTS初始化失败:', error)
      return false
    }
  }

  // 文本转语音
  async synthesizeText(text, options = {}) {
    try {
      const synthesis = {
        id: this.generateTaskId(),
        text: text,
        voice: options.voice || 'standard_female',
        speed: options.speed || 1.0,
        pitch: options.pitch || 1.0,
        volume: options.volume || 1.0,
        format: options.format || 'mp3',
        status: 'pending',
        createdAt: Date.now()
      }

      // 添加到队列
      this.synthesisQueue.push(synthesis)

      // 开始处理
      if (!this.isProcessing) {
        this.processQueue()
      }

      return synthesis.id
    } catch (error) {
      console.error('TTS合成失败:', error)
      throw error
    }
  }

  // 处理合成队列
  async processQueue() {
    if (this.isProcessing || this.synthesisQueue.length === 0) {
      return
    }

    this.isProcessing = true

    while (this.synthesisQueue.length > 0) {
      const synthesis = this.synthesisQueue.shift()
      
      try {
        synthesis.status = 'processing'
        await this.processSingleSynthesis(synthesis)
        synthesis.status = 'completed'
      } catch (error) {
        synthesis.status = 'failed'
        synthesis.error = error.message
      }

      // 通知状态更新
      this.notifyStatusUpdate(synthesis)
    }

    this.isProcessing = false
  }

  // 处理单个合成任务
  async processSingleSynthesis(synthesis) {
    const voiceProfile = this.voiceProfiles[synthesis.voice]
    
    const requestData = {
      text: synthesis.text,
      voice: voiceProfile.voice,
      speed: synthesis.speed,
      pitch: synthesis.pitch,
      volume: synthesis.volume,
      format: synthesis.format,
      sample_rate: 16000
    }

    const response = await this.callTTSAPI(requestData)
    
    if (response.success) {
      // 保存音频文件
      synthesis.audioUrl = await this.saveAudioFile(response.audioData, synthesis.id)
      synthesis.duration = response.duration
    } else {
      throw new Error(response.message || '语音合成失败')
    }
  }

  // 调用TTS API
  async callTTSAPI(requestData) {
    return new Promise((resolve, reject) => {
      uni.request({
        url: this.apiEndpoint,
        method: 'POST',
        header: {
          'Authorization': `Bearer ${this.accessToken}`,
          'Content-Type': 'application/json'
        },
        data: requestData,
        responseType: 'arraybuffer',
        success: (res) => {
          if (res.statusCode === 200) {
            resolve({
              success: true,
              audioData: res.data,
              duration: this.estimateAudioDuration(requestData.text)
            })
          } else {
            reject(new Error(`API调用失败: ${res.statusCode}`))
          }
        },
        fail: reject
      })
    })
  }

  // 保存音频文件
  async saveAudioFile(audioData, taskId) {
    return new Promise((resolve, reject) => {
      const fileName = `tts_${taskId}_${Date.now()}.mp3`
      const filePath = `${uni.env.USER_DATA_PATH}/${fileName}`

      uni.getFileSystemManager().writeFile({
        filePath: filePath,
        data: audioData,
        success: () => {
          resolve(filePath)
        },
        fail: reject
      })
    })
  }

  // 估算音频时长
  estimateAudioDuration(text) {
    // 简单估算：每个字符约0.15秒
    const charCount = text.length
    return Math.ceil(charCount * 0.15)
  }

  // 获取任务状态
  getTaskStatus(taskId) {
    const synthesis = this.synthesisQueue.find(s => s.id === taskId) ||
                     this.completedTasks.find(s => s.id === taskId)
    
    return synthesis ? {
      id: synthesis.id,
      status: synthesis.status,
      progress: this.calculateProgress(synthesis),
      audioUrl: synthesis.audioUrl,
      duration: synthesis.duration,
      error: synthesis.error
    } : null
  }

  // 计算处理进度
  calculateProgress(synthesis) {
    switch (synthesis.status) {
      case 'pending': return 0
      case 'processing': return 50
      case 'completed': return 100
      case 'failed': return 0
      default: return 0
    }
  }

  // 生成任务ID
  generateTaskId() {
    return `tts_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }

  // 获取访问令牌
  async getAccessToken() {
    // 调用后端API获取TTS服务访问令牌
    const response = await api.ai.getTTSToken()
    return response.data.access_token
  }

  // 状态更新通知
  notifyStatusUpdate(synthesis) {
    uni.$emit('tts-status-update', {
      taskId: synthesis.id,
      status: synthesis.status,
      audioUrl: synthesis.audioUrl,
      duration: synthesis.duration,
      error: synthesis.error
    })
  }

  // 清理过期任务
  cleanupExpiredTasks() {
    const now = Date.now()
    const maxAge = 24 * 60 * 60 * 1000 // 24小时

    this.completedTasks = this.completedTasks.filter(task => {
      if (now - task.createdAt > maxAge) {
        // 删除过期音频文件
        if (task.audioUrl) {
          uni.getFileSystemManager().unlink({
            filePath: task.audioUrl,
            success: () => console.log('删除过期TTS文件:', task.audioUrl),
            fail: (error) => console.error('删除TTS文件失败:', error)
          })
        }
        return false
      }
      return true
    })
  }
}

// 全局TTS管理器实例
export const ttsManager = new TTSManager()
```

### 5.2 语音控制功能

#### 语音指令识别
```javascript
class VoiceCommandManager {
  constructor() {
    this.isListening = false
    this.commands = {
      '播放': () => this.playCommand(),
      '暂停': () => this.pauseCommand(),
      '下一首': () => this.nextCommand(),
      '上一首': () => this.previousCommand(),
      '搜索': (params) => this.searchCommand(params),
      '收藏': () => this.favoriteCommand(),
      '音量大一点': () => this.volumeUpCommand(),
      '音量小一点': () => this.volumeDownCommand(),
      '快进': () => this.forwardCommand(),
      '快退': () => this.backwardCommand()
    }
    this.recognizer = null
  }

  // 开始语音识别
  async startListening() {
    try {
      // 检查权限
      const hasPermission = await this.checkMicrophonePermission()
      if (!hasPermission) {
        throw new Error('需要麦克风权限')
      }

      this.isListening = true
      
      // 创建语音识别对象
      this.recognizer = uni.createSpeechRecognizer({
        lang: 'zh_CN',
        continuous: true,
        interimResults: true
      })

      // 绑定事件
      this.recognizer.onResult((result) => {
        this.handleRecognitionResult(result)
      })

      this.recognizer.onError((error) => {
        console.error('语音识别错误:', error)
        this.stopListening()
      })

      // 开始识别
      this.recognizer.start()

      // 显示语音指示器
      this.showVoiceIndicator()

    } catch (error) {
      console.error('启动语音识别失败:', error)
      uni.showToast({
        title: '语音功能不可用',
        icon: 'error'
      })
    }
  }

  // 停止语音识别
  stopListening() {
    this.isListening = false
    
    if (this.recognizer) {
      this.recognizer.stop()
      this.recognizer = null
    }

    this.hideVoiceIndicator()
  }

  // 处理识别结果
  handleRecognitionResult(result) {
    const transcript = result.transcript.trim()
    
    if (result.isFinal) {
      console.log('语音识别结果:', transcript)
      this.executeCommand(transcript)
    } else {
      // 显示临时结果
      this.showTemporaryResult(transcript)
    }
  }

  // 执行语音指令
  executeCommand(transcript) {
    const playerStore = usePlayerStore()
    
    // 匹配指令
    for (const [command, handler] of Object.entries(this.commands)) {
      if (transcript.includes(command)) {
        try {
          // 提取参数
          const params = this.extractCommandParams(transcript, command)
          handler(params)
          
          uni.showToast({
            title: `执行指令: ${command}`,
            icon: 'success'
          })
          
          return
        } catch (error) {
          console.error('执行语音指令失败:', error)
        }
      }
    }

    // 未识别的指令
    uni.showToast({
      title: '未识别的指令',
      icon: 'none'
    })
  }

  // 提取指令参数
  extractCommandParams(transcript, command) {
    const commandIndex = transcript.indexOf(command)
    const afterCommand = transcript.substring(commandIndex + command.length).trim()
    
    return {
      fullText: transcript,
      afterCommand: afterCommand,
      beforeCommand: transcript.substring(0, commandIndex).trim()
    }
  }

  // 播放指令
  playCommand() {
    const playerStore = usePlayerStore()
    
    if (playerStore.currentTrack) {
      playerStore.togglePlay()
    } else {
      // 播放推荐音乐
      this.playRecommendedMusic()
    }
  }

  // 暂停指令
  pauseCommand() {
    const playerStore = usePlayerStore()
    if (playerStore.isPlaying) {
      playerStore.pause()
    }
  }

  // 下一首指令
  nextCommand() {
    const playerStore = usePlayerStore()
    playerStore.playNext()
  }

  // 上一首指令
  previousCommand() {
    const playerStore = usePlayerStore()
    playerStore.playPrevious()
  }

  // 搜索指令
  async searchCommand(params) {
    const query = params.afterCommand
    if (query) {
      uni.navigateTo({
        url: `/pages/discover/search?q=${encodeURIComponent(query)}`
      })
    } else {
      uni.showToast({
        title: '请说出要搜索的内容',
        icon: 'none'
      })
    }
  }

  // 收藏指令
  favoriteCommand() {
    const playerStore = usePlayerStore()
    if (playerStore.currentTrack) {
      // 切换收藏状态
      this.toggleFavorite(playerStore.currentTrack)
    }
  }

  // 音量控制指令
  volumeUpCommand() {
    const playerStore = usePlayerStore()
    const newVolume = Math.min(1.0, playerStore.volume + 0.1)
    playerStore.setVolume(newVolume)
  }

  volumeDownCommand() {
    const playerStore = usePlayerStore()
    const newVolume = Math.max(0.0, playerStore.volume - 0.1)
    playerStore.setVolume(newVolume)
  }

  // 快进/快退指令
  forwardCommand() {
    const playerStore = usePlayerStore()
    const newTime = Math.min(playerStore.duration, playerStore.currentTime + 30)
    playerStore.seek(newTime)
  }

  backwardCommand() {
    const playerStore = usePlayerStore()
    const newTime = Math.max(0, playerStore.currentTime - 15)
    playerStore.seek(newTime)
  }

  // 检查麦克风权限
  async checkMicrophonePermission() {
    return new Promise((resolve) => {
      uni.getSetting({
        success: (res) => {
          if (res.authSetting['scope.record'] === undefined) {
            uni.authorize({
              scope: 'scope.record',
              success: () => resolve(true),
              fail: () => resolve(false)
            })
          } else {
            resolve(res.authSetting['scope.record'])
          }
        },
        fail: () => resolve(false)
      })
    })
  }

  // 显示语音指示器
  showVoiceIndicator() {
    uni.$emit('show-voice-indicator')
  }

  // 隐藏语音指示器
  hideVoiceIndicator() {
    uni.$emit('hide-voice-indicator')
  }

  // 显示临时识别结果
  showTemporaryResult(text) {
    uni.$emit('voice-temp-result', text)
  }
}

// 全局语音指令管理器
export const voiceCommandManager = new VoiceCommandManager()
```

---

*此文档随开发进展持续更新*